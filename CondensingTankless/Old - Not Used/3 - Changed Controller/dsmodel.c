/* DSblock model generated by Dymola from Modelica model TanklessWaterHeater.NonCondensingTanklessHeaterValidation
 Dymola Version 2012 FD01 (32-bit), 2011-11-22 translated this at Fri Sep 07 12:26:09 2012

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC int   Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M(const char* 
   tableName0_0, const char*  fileName0_0, RealArray   table0_0, int  
  smoothness0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(int  
  tableID0_0, int  icol0_0, double  u0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.tableInit
  input String tableName;
  input String fileName;
  input Real table[:, :];
  input Modelica.Blocks.Types.Smoothness smoothness;
  output Integer tableID;

external "C" tableID := ModelicaTables_CombiTable1D_init(tableName, fileName, 
  table, size(table, 1), size(table, 2), smoothness);
annotation(Library={"ModelicaExternalC"});
end Modelica.Blocks.Tables.CombiTable1Ds.tableInit;
*/
DYMOLA_STATIC int   Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M(const char* 
   tableName0_0, const char*  fileName0_0, RealArray   table0_0, int  
  smoothness0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.tableInit")
  {
    /* Declare outputs and temporaries */
    int   tableID0_0;
    tableID0_0=0;
    /* Start of real code */
    {
      extern int (ModelicaTables_CombiTable1D_init)(const char* , const char* , 
        double  const *, int , int , int );
      tableID0_0 = (ModelicaTables_CombiTable1D_init)(tableName0_0, fileName0_0,
         table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return tableID0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.tableIpo
  input Integer tableID;
  input Integer icol;
  input Real u;
  output Real value;

external "C" value := ModelicaTables_CombiTable1D_interpolate(tableID, icol, u);
annotation(Library={"ModelicaExternalC"});
end Modelica.Blocks.Tables.CombiTable1Ds.tableIpo;
*/
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(int  
  tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.tableIpo")
  {
    /* Declare outputs and temporaries */
    double   value0_0;
    value0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaTables_CombiTable1D_interpolate)(int , int , double );
      value0_0 = (ModelicaTables_CombiTable1D_interpolate)(tableID0_0, icol0_0, 
        u0_0);
      }
    /* Output section */
    PopContext()
    return value0_0;
  }}
/* DSblock C-code: */

#include <moutil.c>
DYMOLA_STATIC const char*modelName="TanklessWaterHeater.NonCondensingTanklessHeaterValidation";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/peter grant/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[19]={6 , 3 , 1 , 4 , 7 , 3 , 2 , 5 , 8 , 3 , 3
   , 6 , 9 , 1 , 10 , 1 , 11 , 1 , 12};
DYMOLA_STATIC long QJacobianGC_[73]={
1 , 1 , 4 , 4 , 4 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 5 , 5 , 5 , 8 , 8 , 8
   , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 6 , 6 , 9 , 9 , 9 , 0 , 0 , 10 , 10 , 10 , 10
   , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11
   , 11 , 11 , 11 , 0 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12
   , 0};
DYMOLA_STATIC double QJacobianCD_[13]={0  , 44 , 50 , 54 , 77 , 80 , 81 , 110 , 110
   , 108 , 104 , 98 , 90};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[53] = 4;
W_[71] = true;
W_[72] = true;
W_[88] = 11;
W_[97] = 6;
W_[57] = 5;
W_[58] = true;
W_[70] = true;
W_[103] = 3;
W_[108] = 1;
W_[0] = 10;
W_[79] = 52800;
W_[80] = 0.83;
W_[87] = true;
W_[49] = 1.0;
W_[99] = 1.0;
W_[111] = 1.0;
W_[60] = 1.0;
W_[85] = 1.0;
BoundParameterSection
AssertModelica(DP_[16] >= DP_[17],"nonCondensingTanklessHXController.PID.yMax >= nonCondensingTanklessHXController.PID.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[16], true, 0)),") < yMin (="),Real2String2(DP_[17], true, 0)),
  ")"));;
PopAllMarks();
W_[54] = DP_[33];
W_[55] = DP_[34];
W_[56] = DP_[35];
W_[59] = DP_[36];
W_[62] = DP_[18];
W_[64] = W_[54];
W_[68] = DP_[16];
W_[69] = DP_[17];
W_[74] = W_[80];
W_[75] = W_[79];
W_[76] = DP_[32];
W_[77] = DP_[31];
W_[101] = DP_[19];
W_[102] = divmacro(1,"1",W_[55],"nonCondensingTanklessHXController.PID.Ti");
W_[104] = DP_[22];
W_[106] = W_[56];
helpvar[0] = divmacro(1.0,"1.0",DP_[21],"nonCondensingTanklessHXController.PID.Nd");
W_[107] = RealBmax(helpvar[0]*W_[56], 1E-014);
W_[109] = DP_[23];
if (NewParameters) {
helpvar[1] = fabs(W_[106]);
}
W_[110] = fabs(W_[106]) < 1E-015;
W_[114] = divmacro(1,"1",W_[54]*DP_[20],"nonCondensingTanklessHXController.PID.k*nonCondensingTanklessHXController.PID.Ni");
InitialSection
InitialSection2
X_[10] = W_[104];
X_[11] = W_[109];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
W_[54] = DP_[33];
W_[55] = DP_[34];
W_[56] = DP_[35];
W_[59] = DP_[36];
W_[62] = DP_[18];
W_[64] = W_[54];
W_[68] = DP_[16];
W_[69] = DP_[17];
AssertModelica(W_[68] >= W_[69],"nonCondensingTanklessHXController.PID.limiter.uMax >= nonCondensingTanklessHXController.PID.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[68], true, 0)),") < uMin (="),Real2String2(W_[69], true, 0)),
  ")"));;
PopAllMarks();
W_[74] = W_[80];
W_[75] = W_[79];
W_[76] = DP_[32];
W_[77] = DP_[31];
W_[101] = DP_[19];
W_[102] = divmacro(1,"1",W_[55],"nonCondensingTanklessHXController.PID.Ti");
W_[104] = DP_[22];
W_[106] = W_[56];
W_[107] = RealBmax(divmacro(W_[56],"nonCondensingTanklessHXController.PID.Td",
  DP_[21],"nonCondensingTanklessHXController.PID.Nd"), 1E-014);
W_[109] = DP_[23];
W_[114] = divmacro(1,"1",W_[54]*DP_[20],"nonCondensingTanklessHXController.PID.k*nonCondensingTanklessHXController.PID.Ni");
W_[110] = fabs(W_[106]) < 1E-015;
X_[11] = W_[109];
X_[10] = W_[104];
InitialSection
W_[96] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableInit(\"tab1\", \"C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessValidationNREL.txt\", combiTable1Ds1.table, combiTable1Ds1.smoothness)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M("tab1", "C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessValidationNREL.txt",
   RealTemporaryDense( (Real*)(0), 2, 0, 2), DP_[49]));
PopAllMarks();
InitialSection
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection

DynamicsSection
W_[86] = Time;
W_[78] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[10], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[47], W_[86]));
PopModelContext();
W_[42] = W_[78]*DP_[32];
W_[40] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[1], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[38], W_[86]));
PopModelContext();
W_[41] = DP_[10]*W_[40]+DP_[11]*DP_[31];
W_[43] = W_[42]*W_[41];
W_[82] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[11], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[48], W_[86]));
PopModelContext();
W_[37] = IF Greater(W_[43],"nonCondensingTanklessHXController.product1.y", 
  43824.0,"43824.0", 0) AND Greater(W_[82],"nonCondensingTanklessHXController.PowerSignal",
   0,"0", 1) THEN divmacro(43824.0,"43824.0",W_[76]*(W_[77]-W_[40]),
  "nonCondensingTanklessHXController.FlowRateControl.SpecificHeat*(nonCondensingTanklessHXController.FlowRateControl.T_Set-nonCondensing.T_Inlet)")
   ELSE W_[78];
W_[1] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[47] = GreaterEqual(W_[78],"nonCondensingTanklessHXController.mdot_water", 
  DP_[29],"nonCondensingTanklessHXController.mdot_min_cons", 2);
W_[44] = IF W_[47] THEN DP_[12] ELSE DP_[13];
W_[48] = GreaterEqual(W_[43],"nonCondensingTanklessHXController.product1.y", 
  DP_[30],"nonCondensingTanklessHXController.Qdot_min_cons", 3);
W_[45] = IF W_[48] THEN DP_[14] ELSE DP_[15];
W_[46] = W_[44]*W_[45];
BreakSectionFunction(1);

if (Init || Time==InitTime) {
Aux_[0] = Greater(W_[81],"nonCondensingTanklessHXController.fixedDelay.u", \
1E-011,"1E-011", 4);}
MixedSystemOfEquations(11)
  W_[84] = IF Aux_[0] THEN X_[9] ELSE DP_[31];
  W_[50] = divmacro(W_[84],"nonCondensingTanklessHXController.TOut.TOutMod",
    DP_[31],"nonCondensingTanklessHXController.T_Set_cons");
  W_[100] = W_[101]+DP_[56]*W_[50];
  W_[67] = IF W_[110] THEN 0 ELSE divmacro(W_[106]*(W_[100]-X_[11]),
    "nonCondensingTanklessHXController.PID.D.k*(nonCondensingTanklessHXController.PID.addD.y-nonCondensingTanklessHXController.PID.D.x)",
    W_[107],"nonCondensingTanklessHXController.PID.D.T");
  W_[61] = W_[62]+DP_[24]*W_[50];
  W_[63] = DP_[25]*W_[61];
  W_[65] = DP_[26]*W_[63]+DP_[27]*W_[67]+DP_[28]*X_[10];
  W_[66] = W_[64]*W_[65];
  W_[51] = IF GreaterS(W_[66],"nonCondensingTanklessHXController.PID.gainPID.y",
     W_[68],"nonCondensingTanklessHXController.PID.limiter.uMax", 5) THEN W_[68]
     ELSE IF LessS(W_[66],"nonCondensingTanklessHXController.PID.gainPID.y", 
    W_[69],"nonCondensingTanklessHXController.PID.limiter.uMin", 6) THEN W_[69]
     ELSE W_[66];
  W_[73] = W_[46]*W_[51];
  W_[81] = W_[73]*W_[82];

  MixedModeStartBoolean
  UpdateVariableNamed(Aux_[0],"discreteexpr_0.", Greater(W_[81],"nonCondensingTanklessHXController.fixedDelay.u",
     1E-011,"1E-011", 4));
  MixedModeInit(1)
  ThetaMixedCross(0,4)
  MixedModeEndBoolean
  UpdateReal(W_[100], 1)
  UpdateReal(W_[67], 2)
  UpdateReal(W_[84], 3)
  UpdateReal(W_[50], 4)
  UpdateReal(W_[61], 5)
  UpdateReal(W_[63], 6)
  UpdateReal(W_[65], 7)
  UpdateReal(W_[66], 8)
  UpdateReal(W_[51], 9)
  UpdateReal(W_[73], 10)
  UpdateReal(W_[81], 11)
EndMixedSystemOfEquations

W_[38] = delay(W_[81], DP_[37], 0);
W_[39] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[8], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[45], W_[86]));
PopModelContext();
W_[11] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*W_[40]+10*
  DP_[3]*(X_[1]+W_[40])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Inlet)+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[2]+nonCondensing.T_Inlet))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[0] = W_[1]*X_[0]+W_[11];
W_[2] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[12] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[0]+10*
  DP_[3]*(X_[2]+X_[0])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[1])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[3]+nonCondensing.T_Node[1]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[1] = W_[2]*X_[1]+W_[12];
W_[3] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[13] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[1]+10*
  DP_[3]*(X_[3]+X_[1])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[2])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[4]+nonCondensing.T_Node[2]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[2] = W_[3]*X_[2]+W_[13];
W_[4] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[14] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[2]+10*
  DP_[3]*(X_[4]+X_[2])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[3])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[5]+nonCondensing.T_Node[3]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[3] = W_[4]*X_[3]+W_[14];
W_[5] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[15] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[3]+10*
  DP_[3]*(X_[5]+X_[3])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[4])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[6]+nonCondensing.T_Node[4]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[4] = W_[5]*X_[4]+W_[15];
W_[6] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[16] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[4]+10*
  DP_[3]*(X_[6]+X_[4])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[5])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[7]+nonCondensing.T_Node[5]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[5] = W_[6]*X_[5]+W_[16];
W_[7] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[17] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[5]+10*
  DP_[3]*(X_[7]+X_[5])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[6])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[8]+nonCondensing.T_Node[6]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[6] = W_[7]*X_[6]+W_[17];
W_[8] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[18] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[6]+10*
  DP_[3]*(X_[8]+X_[6])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[7])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[9]+nonCondensing.T_Node[7]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[7] = W_[8]*X_[7]+W_[18];
W_[9] =  -divmacro(10*W_[37]*DP_[7]+20*DP_[3]+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat)+20*nonCondensing.ConductionCoefficient+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[19] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[7]+10*
  DP_[3]*(X_[9]+X_[7])+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[8])+10*(nonCondensing.ConductionCoefficient*(nonCondensing.T_Node[10]+nonCondensing.T_Node[8]))+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[8] = W_[9]*X_[8]+W_[19];
W_[10] =  -divmacro(10*(W_[37]*DP_[7]+DP_[3])+DP_[2],"10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat+nonCondensing.ConductionCoefficient)+nonCondensing.UA",
  DP_[0],"nonCondensing.Capacitance");
W_[20] = divmacro(DP_[1]*W_[38]*DP_[6]+DP_[4]*DP_[5]+10*W_[37]*DP_[7]*X_[8]+10*
  DP_[3]*X_[8]+DP_[2]*W_[39],"nonCondensing.SteadyStateEff*nonCondensing.ControlConstant*nonCondensing.Qdot_Rated+nonCondensing.EffPilot*nonCondensing.Qdot_Pilot+10*(nonCondensing.mdot_water*nonCondensing.SpecificHeat*nonCondensing.T_Node[9])+10*(nonCondensing.ConductionCoefficient*nonCondensing.T_Node[9])+nonCondensing.UA*nonCondensing.T_amb",
  DP_[0],"nonCondensing.Capacitance");
F_[9] = W_[10]*X_[9]+W_[20];
F_[11] = IF W_[110] THEN 0 ELSE divmacro(W_[100]-X_[11],"nonCondensingTanklessHXController.PID.addD.y-nonCondensingTanklessHXController.PID.D.x",
  W_[107],"nonCondensingTanklessHXController.PID.D.T");
W_[113] = DP_[61]*W_[51]+DP_[62]*W_[66];
W_[112] = W_[114]*W_[113];
W_[105] = DP_[58]+DP_[59]*W_[50]+DP_[60]*W_[112];
F_[10] = W_[102]*W_[105];

AcceptedSection1

AcceptedSection2
W_[21] = W_[37]*DP_[7]*(X_[9]-W_[40]);
W_[22] = 0.1*DP_[2]*(X_[0]-W_[39]);
W_[23] = 0.1*DP_[2]*(X_[1]-W_[39]);
W_[24] = 0.1*DP_[2]*(X_[2]-W_[39]);
W_[25] = 0.1*DP_[2]*(X_[3]-W_[39]);
W_[26] = 0.1*DP_[2]*(X_[4]-W_[39]);
W_[27] = 0.1*DP_[2]*(X_[5]-W_[39]);
W_[28] = 0.1*DP_[2]*(X_[6]-W_[39]);
W_[29] = 0.1*DP_[2]*(X_[7]-W_[39]);
W_[30] = 0.1*DP_[2]*(X_[8]-W_[39]);
W_[31] = 0.1*DP_[2]*(X_[9]-W_[39]);
W_[32] = W_[22]+W_[23]+W_[24]+W_[25]+W_[26]+W_[27]+W_[28]+W_[29]+W_[30]+W_[31];
W_[33] = 0.1*DP_[0]*(X_[0]+X_[1]+X_[2]+X_[3]+X_[4]+X_[5]+X_[6]+X_[7]+X_[8]+X_[9]);
W_[34] = 0.1*(X_[0]+X_[1]+X_[2]+X_[3]+X_[4]+X_[5]+X_[6]+X_[7]+X_[8]+X_[9]);
W_[35] = DP_[5]+DP_[6]*W_[38];
W_[36] = IF Greater(W_[38],"nonCondensing.ControlConstant", 0,"0", 7) THEN 
  divmacro(W_[38]*DP_[6],"nonCondensing.ControlConstant*nonCondensing.Qdot_Rated",
  DP_[9],"nonCondensing.EnergyDensityGas") ELSE 0.001;
W_[52] = 1.0-W_[50];
W_[89] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[2], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[39], W_[86]));
PopModelContext();
W_[90] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[3], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[40], W_[86]));
PopModelContext();
W_[91] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[4], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[41], W_[86]));
PopModelContext();
W_[92] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[5], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[42], W_[86]));
PopModelContext();
W_[93] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[6], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[43], W_[86]));
PopModelContext();
W_[94] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[7], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[44], W_[86]));
PopModelContext();
W_[95] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(combiTable1Ds1.tableID, combiTable1Ds1.columns[9], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[96], DP_[46], W_[86]));
PopModelContext();
W_[98] = DP_[50]*W_[89]+DP_[51]*W_[90]+DP_[52]*W_[91]+DP_[53]*W_[92]+DP_[54]*
  W_[93]+DP_[55]*W_[94];
W_[83] = IF Greater(W_[81],"nonCondensingTanklessHXController.fixedDelay.u", 
  1E-011,"1E-011", 4) THEN 1 ELSE 0;

DefaultSection
InitialSection
Aux_[0] = W_[81] > 1E-011;
DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAlias(0)
StartNonAlias(0)
DeclareParameter("nonCondensing.Capacitance", "Thermal capacitance of the heat exchanger [J/C]",\
 0, 18138.9, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.SteadyStateEff", "Heater efficiency at steady state",\
 1, 0.83, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.UA", "Coefficient describing heat loss to ambient conditions [W/C]",\
 2, 3.8, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.ConductionCoefficient", "Coefficient characterizing the conduction of heat in the heat exchanger [W/C]",\
 3, 0.0001, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensing.nNode", "Number of nodes the heat exchanger is broken into",\
 10, 0.0,0.0,0.0,0,517)
DeclareParameter("nonCondensing.EffPilot", "Efficiency of the pilot light", 4, \
0.8, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.Qdot_Pilot", "Input heat rate of the pilot light [W]",\
 5, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.Qdot_Rated", "Rated capacity of the main burner [W]",\
 6, 52800, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.SpecificHeat", "Specific heat of the fluid being heated [J/(kg.C)]",\
 7, 4190, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.T_Set", "Set temperature of the tankless heater [C]",\
 8, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensing.EnergyDensityGas", "[W/kg]", 9, 13500, 0.0,0.0,\
0.0,0,560)
DeclareState("nonCondensing.T_Node[1]", "[C]", 0, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[1])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[2]", "[C]", 1, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[2])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[3]", "[C]", 2, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[3])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[4]", "[C]", 3, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[4])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[5]", "[C]", 4, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[5])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[6]", "[C]", 5, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[6])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[7]", "[C]", 6, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[7])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[8]", "[C]", 7, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[8])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[9]", "[C]", 8, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[9])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensing.T_Node[10]", "[C]", 9, 20, 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensing.der(T_Node[10])", "[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[1]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[2]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[3]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[4]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[5]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[6]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[7]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[8]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[9]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.a[10]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[1]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[2]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[3]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[4]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[5]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[6]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[7]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[8]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[9]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.b[10]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Delivered", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[1]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[2]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[3]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[4]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[5]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[6]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[7]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[8]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[9]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Env[10]", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_Environment", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Q_Stored", "[J]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.AvgTemp", "[C]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.Qdot_in", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.mdot_g", "[kg/hr]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.mdot_water", "[kg/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.ControlConstant", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensing.T_Out", "", "nonCondensing.T_Node[10]", 1, 1, 9, 0)
DeclareVariable("nonCondensing.T_amb", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensing.T_Inlet", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.T_out", "", "nonCondensing.T_Node[10]", 1,\
 1, 9, 0)
DeclareAlias2("nonCondensingTanklessHXController.add.u1", "Connector of Real input signal 1",\
 "nonCondensing.T_Inlet", 1, 5, 40, 0)
DeclareAlias2("nonCondensingTanklessHXController.add.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareVariable("nonCondensingTanklessHXController.add.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHXController.add.k1", "Gain of upper input",\
 10, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.add.k2", "Gain of lower input",\
 11, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.product.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.mdot_water", 1, 5, 78, 0)
DeclareAlias2("nonCondensingTanklessHXController.product.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.SpecificHeat_cons", 1, 7, 32, 0)
DeclareVariable("nonCondensingTanklessHXController.product.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.product1.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.product.y", 1, 5, 42, 0)
DeclareAlias2("nonCondensingTanklessHXController.product1.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.add.y", 1, 5, 41, 0)
DeclareVariable("nonCondensingTanklessHXController.product1.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.mdot_water_controlled", "", \
"nonCondensing.mdot_water", 1, 5, 37, 0)
DeclareAlias2("nonCondensingTanklessHXController.ControlConstant", "", \
"nonCondensing.ControlConstant", 1, 5, 38, 0)
DeclareVariable("nonCondensingTanklessHXController.product2.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHXController.product2.u2", \
"Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHXController.product2.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHXController.booleanToReal.u", \
"Connector of Boolean input signal", false, 0.0,0.0,0.0,0,642)
DeclareParameter("nonCondensingTanklessHXController.booleanToReal.realTrue", \
"Output signal for true Boolean input", 12, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.booleanToReal.realFalse", \
"Output signal for false Boolean input", 13, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.booleanToReal.y", \
"Connector of Real output signal", "nonCondensingTanklessHXController.product2.u1", 1,\
 5, 44, 0)
DeclareVariable("nonCondensingTanklessHXController.booleanToReal1.u", \
"Connector of Boolean input signal", false, 0.0,0.0,0.0,0,642)
DeclareParameter("nonCondensingTanklessHXController.booleanToReal1.realTrue", \
"Output signal for true Boolean input", 14, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.booleanToReal1.realFalse", \
"Output signal for false Boolean input", 15, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.booleanToReal1.y", \
"Connector of Real output signal", "nonCondensingTanklessHXController.product2.u2", 1,\
 5, 45, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.u_s", "Connector of setpoint input signal",\
 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.u_m", "Connector of measurement input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.y", "Connector of actuator output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.controlError", \
"Control error (set point - measurement)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.controllerType", \
"Type of controller", 4, 1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHXController.PID.k", "Gain of controller [1]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.Ti", "Time constant of Integrator block [s]",\
 0.5, 1E-060,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.Td", "Time constant of Derivative block [s]",\
 0.1, 0.0,1E+100,0.0,0,513)
DeclareParameter("nonCondensingTanklessHXController.PID.yMax", "Upper limit of output",\
 16, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.yMin", "Lower limit of output",\
 17, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.wp", "Set-point weight for Proportional block (0..1)",\
 18, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.wd", "Set-point weight for Derivative block (0..1)",\
 19, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 20, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.Nd", "The higher Nd, the more ideal the derivative block",\
 21, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHXController.PID.limitsAtInit", \
"= false, if limits are ignored during initializiation", true, 0.0,0.0,0.0,0,515)
DeclareParameter("nonCondensingTanklessHXController.PID.xi_start", \
"Initial or guess value value for integrator output (= integrator state)", 22, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.xd_start", \
"Initial or guess value for state of derivative block", 23, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.y_start", \
"Initial value of output", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.addP.u1", \
"Connector of Real input signal 1", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHXController.PID.addP.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.PID.u_m", 1, 5, 50, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.addP.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.addP.k1", \
"Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHXController.PID.addP.k2", \
"Gain of lower input", 24, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.P.k", "Gain value multiplied with input signal [1]",\
 25, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.PID.P.u", "Input signal connector",\
 "nonCondensingTanklessHXController.PID.addP.y", 1, 5, 61, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.P.y", "Output signal connector",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.gainPID.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.gainPID.u", \
"Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.gainPID.y", \
"Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHXController.PID.addPID.k1", \
"Gain of upper input", 26, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.addPID.k2", \
"Gain of middle input", 27, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.addPID.k3", \
"Gain of lower input", 28, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.PID.addPID.u1", \
"Connector 1 of Real input signals", "nonCondensingTanklessHXController.PID.P.y", 1,\
 5, 63, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.addPID.u2", \
"Connector 2 of Real input signals", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.PID.addPID.u3", \
"Connector 3 of Real input signals", "nonCondensingTanklessHXController.PID.I.y", 1,\
 1, 10, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.addPID.y", "Connector of Real output signals",\
 "nonCondensingTanklessHXController.PID.gainPID.u", 1, 5, 65, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.limiter.uMax", \
"Upper limits of input signals", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.limiter.uMin", \
"Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.limiter.limitsAtInit", \
"= false, if limits are ignored during initializiation (i.e., y=u)", true, \
0.0,0.0,0.0,0,515)
DeclareAlias2("nonCondensingTanklessHXController.PID.limiter.u", \
"Connector of Real input signal", "nonCondensingTanklessHXController.PID.gainPID.y", 1,\
 5, 66, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.limiter.y", \
"Connector of Real output signal", "nonCondensingTanklessHXController.PID.y", 1,\
 5, 51, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.with_I", "", true, \
0.0,0.0,0.0,0,1539)
DeclareVariable("nonCondensingTanklessHXController.PID.with_D", "", true, \
0.0,0.0,0.0,0,1539)
DeclareAlias2("nonCondensingTanklessHXController.product3.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.product2.y", 1, 5, 46, 0)
DeclareAlias2("nonCondensingTanklessHXController.product3.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.PID.y", 1, 5, 51, 0)
DeclareVariable("nonCondensingTanklessHXController.product3.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.FlowRateControl.SteadyStateEff",\
 "", 0.83, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.FlowRateControl.Qdot_Rated", \
"", 52800, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.FlowRateControl.SpecificHeat",\
 "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.FlowRateControl.T_Set", "", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHXController.FlowRateControl.Qdot_Required",\
 "", "nonCondensingTanklessHXController.product1.y", 1, 5, 43, 0)
DeclareAlias2("nonCondensingTanklessHXController.FlowRateControl.mdot_water_controlled",\
 "", "nonCondensing.mdot_water", 1, 5, 37, 0)
DeclareAlias2("nonCondensingTanklessHXController.FlowRateControl.mdot_water", "",\
 "nonCondensingTanklessHXController.mdot_water", 1, 5, 78, 0)
DeclareAlias2("nonCondensingTanklessHXController.FlowRateControl.T_Inlet", "", \
"nonCondensing.T_Inlet", 1, 5, 40, 0)
DeclareAlias2("nonCondensingTanklessHXController.FlowRateControl.PowerSignal", \
"", "nonCondensingTanklessHXController.PowerSignal", 1, 5, 82, 0)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual.u1", \
"Connector of first Boolean input signal", "nonCondensingTanklessHXController.mdot_water", 1,\
 5, 78, 0)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual.u2", \
"Connector of second Boolean input signal", "nonCondensingTanklessHXController.mdot_min_cons", 1,\
 7, 29, 0)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual.y", \
"Connector of Boolean output signal", "nonCondensingTanklessHXController.booleanToReal.u", 1,\
 5, 47, 65)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual1.u1", \
"Connector of first Boolean input signal", "nonCondensingTanklessHXController.product1.y", 1,\
 5, 43, 0)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual1.u2", \
"Connector of second Boolean input signal", "nonCondensingTanklessHXController.Qdot_min_cons", 1,\
 7, 30, 0)
DeclareAlias2("nonCondensingTanklessHXController.greaterEqual1.y", \
"Connector of Boolean output signal", "nonCondensingTanklessHXController.booleanToReal1.u", 1,\
 5, 48, 65)
DeclareVariable("nonCondensingTanklessHXController.mdot_water", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.mdot_min.y", "Value of Real output",\
 "nonCondensingTanklessHXController.mdot_min_cons", 1, 7, 29, 0)
DeclareParameter("nonCondensingTanklessHXController.mdot_min_cons", \
"Minimum flow rate of the tankless heater [kg/s]", 29, 0.0252, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.Qdot_min_cons", \
"Minimum heat rate of the tankless heater [W]", 30, 5275, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.T_Set_cons", \
"Set Temperature [C]", 31, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.SpecificHeat_cons", \
"Specific heat of the fluid being heated [J/(kg.C)]", 32, 4190, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.Qdot_Rated_cons", \
"Raed heat input rate of the tankless heater [W]", 52800, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.SteadyStateEff_cons", "", \
0.83, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHXController.PID_k", "", 33, 0.25, \
0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID_I", "", 34, 30, 0.0,0.0,\
0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID_D", "", 35, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID_y_start", "", 36, 1E-006,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.SpecificHeat.y", \
"Value of Real output", "nonCondensingTanklessHXController.SpecificHeat_cons", 1,\
 7, 32, 0)
DeclareAlias2("nonCondensingTanklessHXController.T_Set.y", "Value of Real output",\
 "nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareAlias2("nonCondensingTanklessHXController.Qdot_min.y", "Value of Real output",\
 "nonCondensingTanklessHXController.Qdot_min_cons", 1, 7, 30, 0)
DeclareVariable("nonCondensingTanklessHXController.fixedDelay.u", \
"Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.fixedDelay.y", "Connector of Real output signal",\
 "nonCondensing.ControlConstant", 1, 5, 38, 0)
DeclareParameter("nonCondensingTanklessHXController.fixedDelay.delayTime", \
"Delay time of output with respect to input signal [s]", 37, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.T_Inlet", "", "nonCondensing.T_Inlet", 1,\
 5, 40, 0)
DeclareVariable("nonCondensingTanklessHXController.PowerSignal", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.product4.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.product3.y", 1, 5, 73, 0)
DeclareAlias2("nonCondensingTanklessHXController.product4.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.PowerSignal", 1, 5, 82, 0)
DeclareAlias2("nonCondensingTanklessHXController.product4.y", "Connector of Real output signal",\
 "nonCondensingTanklessHXController.fixedDelay.u", 1, 5, 81, 0)
DeclareVariable("nonCondensingTanklessHXController.TOut.Debug", "", 0.0, \
0.0,0.0,0.0,0,640)
DeclareAlias2("nonCondensingTanklessHXController.TOut.T_set", "", \
"nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareAlias2("nonCondensingTanklessHXController.TOut.Product4", "", \
"nonCondensingTanklessHXController.fixedDelay.u", 1, 5, 81, 0)
DeclareVariable("nonCondensingTanklessHXController.TOut.TOutMod", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.TOut.TOut", "", \
"nonCondensing.T_Node[10]", 1, 1, 9, 0)
DeclareAlias2("nonCondensingTanklessHXController.division.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.TOut.TOutMod", 1, 5, 84, 0)
DeclareAlias2("nonCondensingTanklessHXController.division.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareAlias2("nonCondensingTanklessHXController.division.y", "Connector of Real output signal",\
 "nonCondensingTanklessHXController.PID.u_m", 1, 5, 50, 0)
DeclareAlias2("nonCondensingTanklessHXController.division1.u1", "Connector of Real input signal 1",\
 "nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareAlias2("nonCondensingTanklessHXController.division1.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.T_Set_cons", 1, 7, 31, 0)
DeclareVariable("nonCondensingTanklessHXController.division1.y", \
"Connector of Real output signal", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Time.y", "Value of Real output", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.tableOnFile", "true, if table is defined on file or in function usertab",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("combiTable1Ds1.columns[1]", "columns of table to be interpolated",\
 38, 2, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[2]", "columns of table to be interpolated",\
 39, 3, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[3]", "columns of table to be interpolated",\
 40, 4, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[4]", "columns of table to be interpolated",\
 41, 5, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[5]", "columns of table to be interpolated",\
 42, 6, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[6]", "columns of table to be interpolated",\
 43, 7, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[7]", "columns of table to be interpolated",\
 44, 8, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[8]", "columns of table to be interpolated",\
 45, 9, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[9]", "columns of table to be interpolated",\
 46, 10, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[10]", "columns of table to be interpolated",\
 47, 11, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.columns[11]", "columns of table to be interpolated",\
 48, 12, 0.0,0.0,0.0,0,564)
DeclareParameter("combiTable1Ds1.smoothness", "smoothness of table interpolation",\
 49, 1, 1.0,2.0,0.0,0,564)
DeclareVariable("combiTable1Ds1.nout", "Number of outputs", 11, 0.0,0.0,0.0,0,517)
DeclareAlias2("combiTable1Ds1.u", "Connector of Real input signal", "Time.y", 1,\
 5, 86, 0)
DeclareAlias2("combiTable1Ds1.y[1]", "Connector of Real output signals", \
"nonCondensing.T_Inlet", 1, 5, 40, 0)
DeclareVariable("combiTable1Ds1.y[2]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.y[3]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.y[4]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.y[5]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.y[6]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("combiTable1Ds1.y[7]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("combiTable1Ds1.y[8]", "Connector of Real output signals", \
"nonCondensing.T_amb", 1, 5, 39, 0)
DeclareVariable("combiTable1Ds1.y[9]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("combiTable1Ds1.y[10]", "Connector of Real output signals", \
"nonCondensingTanklessHXController.mdot_water", 1, 5, 78, 0)
DeclareAlias2("combiTable1Ds1.y[11]", "Connector of Real output signals", \
"nonCondensingTanklessHXController.PowerSignal", 1, 5, 82, 0)
DeclareVariable("combiTable1Ds1.tableID", "", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("SumNodesExp.nin", "Number of inputs", 6, 0.0,0.0,0.0,0,517)
DeclareAlias2("SumNodesExp.u[1]", "Connector of Real input signals", \
"combiTable1Ds1.y[2]", 1, 5, 89, 0)
DeclareAlias2("SumNodesExp.u[2]", "Connector of Real input signals", \
"combiTable1Ds1.y[3]", 1, 5, 90, 0)
DeclareAlias2("SumNodesExp.u[3]", "Connector of Real input signals", \
"combiTable1Ds1.y[4]", 1, 5, 91, 0)
DeclareAlias2("SumNodesExp.u[4]", "Connector of Real input signals", \
"combiTable1Ds1.y[5]", 1, 5, 92, 0)
DeclareAlias2("SumNodesExp.u[5]", "Connector of Real input signals", \
"combiTable1Ds1.y[6]", 1, 5, 93, 0)
DeclareAlias2("SumNodesExp.u[6]", "Connector of Real input signals", \
"combiTable1Ds1.y[7]", 1, 5, 94, 0)
DeclareVariable("SumNodesExp.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("SumNodesExp.k[1]", "Optional: sum coefficients", 50, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("SumNodesExp.k[2]", "Optional: sum coefficients", 51, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("SumNodesExp.k[3]", "Optional: sum coefficients", 52, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("SumNodesExp.k[4]", "Optional: sum coefficients", 53, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("SumNodesExp.k[5]", "Optional: sum coefficients", 54, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("SumNodesExp.k[6]", "Optional: sum coefficients", 55, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.addD.u1", \
"Connector of Real input signal 1", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHXController.PID.addD.u2", "Connector of Real input signal 2",\
 "nonCondensingTanklessHXController.PID.u_m", 1, 5, 50, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.addD.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.addD.k1", \
"Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHXController.PID.addD.k2", \
"Gain of lower input", 56, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.I.k", "Integrator gain [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.I.initType", \
"Type of initialization (1: no init, 2: steady state, 3,4: initial output)", 3, \
1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHXController.PID.I.y_start", \
"Initial or guess value of output (= state)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.I.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHXController.PID.I.y", "Connector of Real output signal",\
 10, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("nonCondensingTanklessHXController.PID.I.der(y)", \
"der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.D.k", "Gains [1]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-060, 1E-060,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHXController.PID.D.initType", \
"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHXController.PID.D.x_start", \
"Initial or guess value of state", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHXController.PID.D.y_start", \
"Initial value of output (= state)", 57, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHXController.PID.D.u", "Connector of Real input signal",\
 "nonCondensingTanklessHXController.PID.addD.y", 1, 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.D.y", "Connector of Real output signal",\
 "nonCondensingTanklessHXController.PID.addPID.u2", 1, 5, 67, 0)
DeclareState("nonCondensingTanklessHXController.PID.D.x", "State of block", 11, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("nonCondensingTanklessHXController.PID.D.der(x)", \
"der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHXController.PID.D.zeroGain", "", false, \
0.0,0.0,0.0,0,2563)
DeclareParameter("nonCondensingTanklessHXController.PID.addI.k1", \
"Gain of upper input", 58, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.addI.k2", \
"Gain of middle input", 59, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.addI.k3", \
"Gain of lower input", 60, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.addI.u1", \
"Connector 1 of Real input signals", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHXController.PID.addI.u2", "Connector 2 of Real input signals",\
 "nonCondensingTanklessHXController.PID.u_m", 1, 5, 50, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.addI.u3", \
"Connector 3 of Real input signals", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHXController.PID.addI.y", "Connector of Real output signals",\
 "nonCondensingTanklessHXController.PID.I.u", 1, 5, 105, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.addSat.u1", \
"Connector of Real input signal 1", "nonCondensingTanklessHXController.PID.y", 1,\
 5, 51, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.addSat.u2", \
"Connector of Real input signal 2", "nonCondensingTanklessHXController.PID.gainPID.y", 1,\
 5, 66, 0)
DeclareVariable("nonCondensingTanklessHXController.PID.addSat.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHXController.PID.addSat.k1", \
"Gain of upper input", 61, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHXController.PID.addSat.k2", \
"Gain of lower input", 62, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHXController.PID.gainTrack.k", \
"Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHXController.PID.gainTrack.u", \
"Input signal connector", "nonCondensingTanklessHXController.PID.addSat.y", 1, 5,\
 113, 0)
DeclareAlias2("nonCondensingTanklessHXController.PID.gainTrack.y", \
"Output signal connector", "nonCondensingTanklessHXController.PID.addI.u3", 1, 5,\
 112, 0)
EndNonAlias(0)
#define NX_    12
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    115
#define NP_    63
#define NPS_   0
#define NHash1_ 21473658
#define NHash2_ 593203758
#define NHash3_ -523114807
#define NI_    0
#define NRelF_ 7
#define NRel_  8
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    69
#define SizePre_ 0
#define SizeEq_ 0
#define SizeDelay_ 1
#define QNLmax_ 0
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 2
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
EndDataBlock
