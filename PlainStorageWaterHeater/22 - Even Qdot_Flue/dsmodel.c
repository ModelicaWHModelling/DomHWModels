/* DSblock model generated by Dymola from Modelica model TanklessWaterHeater.Examples.NonCondensingTanklessExample
 Dymola Version 2012 FD01 (32-bit), 2011-11-22 translated this at Mon Aug 20 11:32:15 2012

   */

#include <matrixop.h>
static const char* DymArrays5[1]={"("};
static const char* DymArrays4[1]={")"};
static const char* DymArrays0[1]={"="};
static const char* DymArrays1[2]={";", ""};
static const char* DymArrays3[3]={"*", "/", ""};
static const char* DymArrays2[3]={"+", "-", ""};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  boolean_0member;
  int  integer_0member;
  double  real_0member;
  const char*  string_0member;
  int  tokenType_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   boolean_02, int   
  integer_02, double   real_02, const char*   string_02, int   tokenType_02) {
  struct DymStruc0 dummy_0;
  dummy_0.boolean_0member = boolean_02;
  dummy_0.integer_0member = integer_02;
  dummy_0.real_0member = real_02;
  dummy_0.string_0member = string_02;
  dummy_0.tokenType_0member = tokenType_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC int   Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M(const char* 
   tableName0_0, const char*  fileName0_0, RealArray   table0_0, int  
  smoothness0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(int  
  tableID0_0, int  icol0_0, double  u0_0);
struct Modelica_Utilities_Examples_expression_struct {
  double   result0_0_0member;
  int   nextIndex0_0_0member;
};
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_struct 
  Modelica_Utilities_Examples_expression(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0);
struct Modelica_Utilities_Examples_expression_primary_struct {
  double   result0_0_0member;
  int   nextIndex0_0_0member;
};
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_primary_struct 
  Modelica_Utilities_Examples_expression_primary(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0);
struct Modelica_Utilities_Examples_expression_term_struct {
  double   result0_0_0member;
  int   nextIndex0_0_0member;
};
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_term_struct 
  Modelica_Utilities_Examples_expression_term(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0);
DYMOLA_STATIC double   Modelica_Utilities_Examples_readRealParameter(const char* 
   fileName0_0, const char*  name0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_Advanced_skipLineComments(
  const char*  string0_0, int  startIndex0_0);
DYMOLA_STATIC const char*   Modelica_Utilities_Strings_repeat(int  n0_0, 
  const char*  string0_0);
struct Modelica_Utilities_Strings_scanDelimiter_struct {
  const char*   delimiter0_0_0member;
  int   nextIndex0_0_0member;
};
DYMOLA_STATIC struct Modelica_Utilities_Strings_scanDelimiter_struct 
  Modelica_Utilities_Strings_scanDelimiter(const char*  string0_0, int  
  startIndex0_0, StringArray   requiredDelimiters0_0, const char*  message0_0);
DYMOLA_STATIC const char*   Modelica_Utilities_Strings_scanDelimiter_concatenate
  (StringArray   strings0_0);
DYMOLA_STATIC void Modelica_Utilities_Strings_scanNoToken(const char*  string0_0,
   int  startIndex0_0, const char*  message0_0);
struct Modelica_Utilities_Strings_scanToken_struct {
  struct DymStruc0  token0_0_0member;
  int   nextIndex0_0_0member;
};
DYMOLA_STATIC struct Modelica_Utilities_Strings_scanToken_struct 
  Modelica_Utilities_Strings_scanToken(const char*  string0_0, int  
  startIndex0_0, int  unsigned0_0);
DYMOLA_STATIC void Modelica_Utilities_Strings_syntaxError(const char*  string0_0,
   int  index0_0, const char*  message0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.tableInit
  input String tableName;
  input String fileName;
  input Real table[:, :];
  input Modelica.Blocks.Types.Smoothness smoothness;
  output Integer tableID;

external "C" tableID := ModelicaTables_CombiTable1D_init(tableName, fileName, 
  table, size(table, 1), size(table, 2), smoothness);
annotation(Library={"ModelicaExternalC"});
end Modelica.Blocks.Tables.CombiTable1Ds.tableInit;
*/
DYMOLA_STATIC int   Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M(const char* 
   tableName0_0, const char*  fileName0_0, RealArray   table0_0, int  
  smoothness0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.tableInit")
  {
    /* Declare outputs and temporaries */
    int   tableID0_0;
    tableID0_0=0;
    /* Start of real code */
    {
      extern int (ModelicaTables_CombiTable1D_init)(const char* , const char* , 
        double  const *, int , int , int );
      tableID0_0 = (ModelicaTables_CombiTable1D_init)(tableName0_0, fileName0_0,
         table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return tableID0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.tableIpo
  input Integer tableID;
  input Integer icol;
  input Real u;
  output Real value;

external "C" value := ModelicaTables_CombiTable1D_interpolate(tableID, icol, u);
annotation(Library={"ModelicaExternalC"});
end Modelica.Blocks.Tables.CombiTable1Ds.tableIpo;
*/
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(int  
  tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.tableIpo")
  {
    /* Declare outputs and temporaries */
    double   value0_0;
    value0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaTables_CombiTable1D_interpolate)(int , int , double );
      value0_0 = (ModelicaTables_CombiTable1D_interpolate)(tableID0_0, icol0_0, 
        u0_0);
      }
    /* Output section */
    PopContext()
    return value0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Examples.readRealParameter
  input String fileName "Name of file";
  input String name "Name of parameter";
  output Real result "Actual value of parameter on file";
protected 
  String line;
  String identifier;
  String delimiter;
  Integer nextIndex;
  Integer iline := 1;
  Modelica.Utilities.Types.TokenValue token;
  String message := "in file \""+fileName+"\" on line ";
  String message2;
  Boolean found := false;
  Boolean endOfFile := false;
  public 
algorithm 
  (line, endOfFile)  := ModelicaInternal_readLine(fileName, iline);
  while  not found and  not endOfFile loop
    (token, nextIndex)  := Modelica.Utilities.Strings.scanToken(line, 1, false);
    if (token.tokenType == Modelica.Utilities.Types.TokenType.NoToken) then 
      iline := iline+1;
    elseif (token.tokenType == Modelica.Utilities.Types.TokenType.
      IdentifierToken) then 
      if (token.string == name) then 
        message2 := message+       String(iline, true, 0);
        (delimiter, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(line,
           nextIndex, {"="}, message2);
        (result, nextIndex)  := Modelica.Utilities.Examples.expression(line, 
          nextIndex, message2);
        (delimiter, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(line,
           nextIndex, {";", ""}, message2);
        Modelica.Utilities.Strings.scanNoToken(line, nextIndex, message2);
        found := true;
      else
        iline := iline+1;
      end if;
    else
      Modelica.Utilities.Strings.syntaxError(line, nextIndex, "Expected identifier "
        +message+       String(iline, true, 0));
    end if;
    (line, endOfFile)  := ModelicaInternal_readLine(fileName, iline);
  end while;
  if ( not found) then 
    ModelicaError("Parameter \""+name+"\" not found in file \""+fileName+"\"");
  end if;
end Modelica.Utilities.Examples.readRealParameter;
*/
DYMOLA_STATIC double   Modelica_Utilities_Examples_readRealParameter(const char* 
   fileName0_0, const char*  name0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Examples.readRealParameter")
  {
    /* Declare outputs and temporaries */
    double   result0_0;
    const char*   line0_0;
    const char*   identifier0_0;
    const char*   delimiter0_0;
    int   nextIndex0_0;
    int   iline0_0;
    struct DymStruc0  token0_0;
    const char*   message0_0;
    const char*   message20_0;
    int   found0_0;
    int   endOfFile0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    line0_0="";
    identifier0_0="";
    delimiter0_0="";
    nextIndex0_0=0;
    iline0_0 = 1;
    token0_0.tokenType_0member=0;
    token0_0.real_0member=0;
    token0_0.integer_0member=0;
    token0_0.boolean_0member=0;
    token0_0.string_0member="";
    message0_0 = StringAdd(StringAdd("in file \"",fileName0_0),"\" on line ");
    message20_0="";
    found0_0 = false;
    endOfFile0_0 = false;
    /* Start of real code */
      {
        struct ModelicaInternal_readLine_M_struct dummy_mult_=ModelicaInternal_readLine_M
          (fileName0_0, iline0_0);
        line0_0 = dummy_mult_.string0_0_0member;
        endOfFile0_0 = dummy_mult_.endOfFile0_0_0member;
      }
      while ( NOT found0_0 AND  NOT endOfFile0_0) {
        {
          struct Modelica_Utilities_Strings_scanToken_struct dummy_mult_=
            Modelica_Utilities_Strings_scanToken(line0_0, 1, false);
          token0_0 = dummy_mult_.token0_0_0member;
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
        }
        if (token0_0.tokenType_0member == 7) {
          iline0_0 = iline0_0+1;
        }
        else if (token0_0.tokenType_0member == 5) {
          if ((strcmp(token0_0.string_0member, name0_0)==0)) {
            message20_0 = StringAdd(message0_0,Integer2String2(iline0_0, true, 0));
            {
              struct Modelica_Utilities_Strings_scanDelimiter_struct
                 dummy_mult_=Modelica_Utilities_Strings_scanDelimiter(line0_0, 
                nextIndex0_0, StringTemporaryDense( DymArrays0, 1, 1), 
                message20_0);
              delimiter0_0 = dummy_mult_.delimiter0_0_0member;
              nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            }
            Release();
            {
              struct Modelica_Utilities_Examples_expression_struct dummy_mult_=
                Modelica_Utilities_Examples_expression(line0_0, nextIndex0_0, 
                message20_0);
              result0_0 = dummy_mult_.result0_0_0member;
              nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            }
            {
              struct Modelica_Utilities_Strings_scanDelimiter_struct
                 dummy_mult_=Modelica_Utilities_Strings_scanDelimiter(line0_0, 
                nextIndex0_0, StringTemporaryDense( DymArrays1, 1, 2), 
                message20_0);
              delimiter0_0 = dummy_mult_.delimiter0_0_0member;
              nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            }
            Release();
            Modelica_Utilities_Strings_scanNoToken(line0_0, nextIndex0_0, 
              message20_0);
            found0_0 = true;
          }
          else{
            iline0_0 = iline0_0+1;
          }
        }
        else{
          Modelica_Utilities_Strings_syntaxError(line0_0, nextIndex0_0, 
            StringAdd(StringAdd("Expected identifier ",message0_0),
            Integer2String2(iline0_0, true, 0)));
        }
        {
          struct ModelicaInternal_readLine_M_struct dummy_mult_=ModelicaInternal_readLine_M
            (fileName0_0, iline0_0);
          line0_0 = dummy_mult_.string0_0_0member;
          endOfFile0_0 = dummy_mult_.endOfFile0_0_0member;
        }
      }
      if ( NOT found0_0) {
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd("Parameter \"",
          name0_0),"\" not found in file \""),fileName0_0),"\""));
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.scanDelimiter
  input String string "String to be scanned";
  input Integer startIndex := 1 "Start scanning of delimiters at character startIndex";
  input String requiredDelimiters[:] "Delimiters that are searched";
  input String message := "" "Message used in error message if scan is not successful";
  output String delimiter "Found delimiter";
  output Integer nextIndex "Index of character after the found delimiter";
protected 
  Integer lenString := ModelicaStrings_length(string);
  Integer lenDelimiter;
  Integer nDelimiters := size(requiredDelimiters, 1);
  Integer endIndex;
  Boolean found;
  Integer i;
  public 
algorithm 
  nextIndex := Modelica.Utilities.Strings.Advanced.skipLineComments(string, 
    startIndex);
  found := false;
  i := 1;
  while  not found and i <= nDelimiters loop
    lenDelimiter := ModelicaStrings_length(requiredDelimiters[i]);
    if (lenDelimiter == 0) then 
      found := true;
      delimiter := "";
    else
      endIndex := nextIndex+lenDelimiter-1;
      if (endIndex <= lenString) then 
        if (ModelicaStrings_substring(string, nextIndex, endIndex) == 
          requiredDelimiters[i]) then 
          found := true;
          delimiter := requiredDelimiters[i];
        end if;
      end if;
      i := i+1;
    end if;
  end while;
  if (found) then 
    nextIndex := nextIndex+lenDelimiter;
  else
    if (size(requiredDelimiters, 1) == 1) then 
      Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected delimiter \""
        +requiredDelimiters[1]+"\"\n"+message);
    else
      Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected a delimiter out of "
        +Modelica.Utilities.Strings.scanDelimiter.concatenate(requiredDelimiters)
        +"\n"+message);
    end if;
  end if;
end Modelica.Utilities.Strings.scanDelimiter;
*/
DYMOLA_STATIC struct Modelica_Utilities_Strings_scanDelimiter_struct 
  Modelica_Utilities_Strings_scanDelimiter(const char*  string0_0, int  
  startIndex0_0, StringArray   requiredDelimiters0_0, const char*  message0_0) {
  PushContext("Modelica.Utilities.Strings.scanDelimiter")
  {
    /* Declare outputs and temporaries */
    const char*   delimiter0_0;
    int   nextIndex0_0;
    int   lenString0_0;
    int   lenDelimiter0_0;
    int   nDelimiters0_0;
    int   endIndex0_0;
    int   found0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    delimiter0_0="";
    nextIndex0_0=0;
    lenString0_0 = ModelicaStrings_length(string0_0);
    lenDelimiter0_0=0;
    nDelimiters0_0 = StringSize( requiredDelimiters0_0, 1);
    endIndex0_0=0;
    found0_0=0;
    i0_0=0;
    /* Start of real code */
      nextIndex0_0 = Modelica_Utilities_Strings_Advanced_skipLineComments(
        string0_0, startIndex0_0);
      found0_0 = false;
      i0_0 = 1;
      while ( NOT found0_0 AND i0_0 <= nDelimiters0_0) {
        lenDelimiter0_0 = ModelicaStrings_length(StringElement( requiredDelimiters0_0,
           (SizeType)( i0_0 )));
        if (lenDelimiter0_0 == 0) {
          found0_0 = true;
          delimiter0_0 = "";
        }
        else{
          endIndex0_0 = nextIndex0_0+lenDelimiter0_0-1;
          if (endIndex0_0 <= lenString0_0) {
            if ((strcmp(ModelicaStrings_substring(string0_0, nextIndex0_0, 
              endIndex0_0), StringElement( requiredDelimiters0_0, (SizeType)( 
              i0_0 )))==0)) {
              found0_0 = true;
              delimiter0_0 = StringElement( requiredDelimiters0_0, (SizeType)( 
                i0_0 ));
            }
          }
          i0_0 = i0_0+1;
        }
      }
      if (found0_0) {
        nextIndex0_0 = nextIndex0_0+lenDelimiter0_0;
      }
      else{
        if (StringSize( requiredDelimiters0_0, 1) == 1) {
          Modelica_Utilities_Strings_syntaxError(string0_0, nextIndex0_0, 
            StringAdd(StringAdd(StringAdd("Expected delimiter \"",
            StringVectorElement( requiredDelimiters0_0, (SizeType)( 1 ))),"\"\n"),
            message0_0));
        }
        else{
          Modelica_Utilities_Strings_syntaxError(string0_0, nextIndex0_0, 
            StringAdd(StringAdd(StringAdd("Expected a delimiter out of ",
            Modelica_Utilities_Strings_scanDelimiter_concatenate(
            requiredDelimiters0_0)),"\n"),message0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Utilities_Strings_scanDelimiter_struct out_;
      out_.delimiter0_0_0member = delimiter0_0;
      out_.nextIndex0_0_0member = nextIndex0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.scanDelimiter.concatenate
  input String strings[:];
  output String string;

algorithm 
  string := "{\"";
  for i in (1:size(strings, 1)) loop
    if (i == 1) then 
      string := "{\""+strings[1]+"\"";
    else
      string := string+", \""+strings[i]+"\"";
    end if;
  end for;
  string := string+"}";
end Modelica.Utilities.Strings.scanDelimiter.concatenate;
*/
DYMOLA_STATIC const char*   Modelica_Utilities_Strings_scanDelimiter_concatenate
  (StringArray   strings0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Strings.scanDelimiter.concatenate")
  {
    /* Declare outputs and temporaries */
    const char*   string0_0;
    MarkObject retmark_ = PushMark();
    string0_0="";
    /* Start of real code */
      string0_0 = "{\"";
      {
        int end_ = StringSize( strings0_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          if (i0_0_0 == 1) {
            string0_0 = StringAdd(StringAdd("{\"",StringVectorElement( 
              strings0_0, (SizeType)( 1 ))),"\"");
          }
          else{
            string0_0 = StringAdd(StringAdd(StringAdd(string0_0,", \""),
              StringElement( strings0_0, (SizeType)( i0_0_0 ))),"\"");
          }
        }
      }
      string0_0 = StringAdd(string0_0,"}");
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return SqueezeString(string0_0, retSMark_);
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.scanNoToken
  input String string "String to be scanned";
  input Integer startIndex := 1 "Start scanning of string at character startIndex";
  input String message := "" "Message used in error message if scan is not successful";
protected 
  Integer nextIndex;
  public 
algorithm 
  nextIndex := Modelica.Utilities.Strings.Advanced.skipLineComments(string, 
    startIndex);
  if (nextIndex <= ModelicaStrings_length(string)) then 
    Modelica.Utilities.Strings.syntaxError(string, nextIndex, "Expected no more token "
      +message);
  end if;
end Modelica.Utilities.Strings.scanNoToken;
*/
DYMOLA_STATIC void Modelica_Utilities_Strings_scanNoToken(const char*  string0_0,
   int  startIndex0_0, const char*  message0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Strings.scanNoToken")
  {
    /* Declare outputs and temporaries */
    int   nextIndex0_0;
    nextIndex0_0=0;
    /* Start of real code */
      nextIndex0_0 = Modelica_Utilities_Strings_Advanced_skipLineComments(
        string0_0, startIndex0_0);
      if (nextIndex0_0 <= ModelicaStrings_length(string0_0)) {
        Modelica_Utilities_Strings_syntaxError(string0_0, nextIndex0_0, 
          StringAdd("Expected no more token ",message0_0));
      }
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.scanToken
  input String string "String to be scanned";
  input Integer startIndex := 1 "Start scanning of string at character startIndex";
  input Boolean unsigned := false "= true, if Real and Integer tokens shall not start with a sign";
  output Modelica.Utilities.Types.TokenValue token;
  output Integer nextIndex "Index of character after the found token; = 0, if NoToken";
protected 
  Integer startTokenIndex;
  public 
algorithm 
  token.real := 0.0;
  token.integer := 0;
  token.boolean := false;
  token.string := "";
  startTokenIndex := Modelica.Utilities.Strings.Advanced.skipLineComments(string,
     startIndex);
  if (startTokenIndex > ModelicaStrings_length(string)) then 
    token.tokenType := Modelica.Utilities.Types.TokenType.NoToken;
    nextIndex := startTokenIndex;
  else
    (nextIndex, token.integer)  := ModelicaStrings_scanInteger(string, 
      startTokenIndex, unsigned);
    token.tokenType := Modelica.Utilities.Types.TokenType.IntegerToken;
    if (nextIndex == startTokenIndex) then 
      (nextIndex, token.real)  := ModelicaStrings_scanReal(string, 
        startTokenIndex, unsigned);
      token.tokenType := Modelica.Utilities.Types.TokenType.RealToken;
    end if;
    if (nextIndex == startTokenIndex) then 
      (nextIndex, token.string)  := ModelicaStrings_scanString(string, 
        startTokenIndex);
      token.tokenType := Modelica.Utilities.Types.TokenType.StringToken;
    end if;
    if (nextIndex == startTokenIndex) then 
      (nextIndex, token.string)  := ModelicaStrings_scanIdentifier(string, 
        startTokenIndex);
      if (nextIndex > startTokenIndex) then 
        if (token.string == "false") then 
          token.string := "";
          token.boolean := false;
          token.tokenType := Modelica.Utilities.Types.TokenType.BooleanToken;
        elseif (token.string == "true") then 
          token.string := "";
          token.boolean := true;
          token.tokenType := Modelica.Utilities.Types.TokenType.BooleanToken;
        else
          token.tokenType := Modelica.Utilities.Types.TokenType.IdentifierToken;
        end if;
      end if;
    end if;
    if (nextIndex == startTokenIndex) then 
      token.string := ModelicaStrings_substring(string, startTokenIndex, 
        startTokenIndex);
      token.tokenType := Modelica.Utilities.Types.TokenType.DelimiterToken;
      nextIndex := startTokenIndex+1;
    end if;
  end if;
end Modelica.Utilities.Strings.scanToken;
*/
DYMOLA_STATIC struct Modelica_Utilities_Strings_scanToken_struct 
  Modelica_Utilities_Strings_scanToken(const char*  string0_0, int  
  startIndex0_0, int  unsigned0_0) {
  PushContext("Modelica.Utilities.Strings.scanToken")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  token0_0;
    int   nextIndex0_0;
    int   startTokenIndex0_0;
    token0_0.tokenType_0member=0;
    token0_0.real_0member=0;
    token0_0.integer_0member=0;
    token0_0.boolean_0member=0;
    token0_0.string_0member="";
    nextIndex0_0=0;
    startTokenIndex0_0=0;
    /* Start of real code */
      token0_0.real_0member = 0.0;
      token0_0.integer_0member = 0;
      token0_0.boolean_0member = false;
      token0_0.string_0member = "";
      startTokenIndex0_0 = Modelica_Utilities_Strings_Advanced_skipLineComments(
        string0_0, startIndex0_0);
      if (startTokenIndex0_0 > ModelicaStrings_length(string0_0)) {
        token0_0.tokenType_0member = 7;
        nextIndex0_0 = startTokenIndex0_0;
      }
      else{
        {
          struct ModelicaStrings_scanInteger_M_struct dummy_mult_=
            ModelicaStrings_scanInteger_M(string0_0, startTokenIndex0_0, 
            unsigned0_0);
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          token0_0.integer_0member = dummy_mult_.number0_0_0member;
        }
        token0_0.tokenType_0member = 2;
        if (nextIndex0_0 == startTokenIndex0_0) {
          {
            struct ModelicaStrings_scanReal_M_struct dummy_mult_=
              ModelicaStrings_scanReal_M(string0_0, startTokenIndex0_0, 
              unsigned0_0);
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            token0_0.real_0member = dummy_mult_.number0_0_0member;
          }
          token0_0.tokenType_0member = 1;
        }
        if (nextIndex0_0 == startTokenIndex0_0) {
          {
            struct ModelicaStrings_scanString_M_struct dummy_mult_=
              ModelicaStrings_scanString_M(string0_0, startTokenIndex0_0);
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            token0_0.string_0member = dummy_mult_.string20_0_0member;
          }
          token0_0.tokenType_0member = 4;
        }
        if (nextIndex0_0 == startTokenIndex0_0) {
          {
            struct ModelicaStrings_scanIdentifier_M_struct dummy_mult_=
              ModelicaStrings_scanIdentifier_M(string0_0, startTokenIndex0_0);
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
            token0_0.string_0member = dummy_mult_.identifier0_0_0member;
          }
          if (nextIndex0_0 > startTokenIndex0_0) {
            if ((strcmp(token0_0.string_0member, "false")==0)) {
              token0_0.string_0member = "";
              token0_0.boolean_0member = false;
              token0_0.tokenType_0member = 3;
            }
            else if ((strcmp(token0_0.string_0member, "true")==0)) {
              token0_0.string_0member = "";
              token0_0.boolean_0member = true;
              token0_0.tokenType_0member = 3;
            }
            else{
              token0_0.tokenType_0member = 5;
            }
          }
        }
        if (nextIndex0_0 == startTokenIndex0_0) {
          token0_0.string_0member = ModelicaStrings_substring(string0_0, 
            startTokenIndex0_0, startTokenIndex0_0);
          token0_0.tokenType_0member = 6;
          nextIndex0_0 = startTokenIndex0_0+1;
        }
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Utilities_Strings_scanToken_struct out_;
      out_.token0_0_0member = token0_0;
      out_.nextIndex0_0_0member = nextIndex0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.syntaxError
  input String string "String that has an error at position index";
  input Integer index "Index of string at which scanning detected an error";
  input String message := "" "String printed at end of error message";
protected 
  Integer maxIndex := 40;
  Integer maxLenString := 60;
  Integer lenString := ModelicaStrings_length(string);
  String errString;
  Integer index2 := (if index < 1 then 1 else (if index > lenString then 
    lenString else index));
  public 
algorithm 
  if (index2 <= maxIndex) then 
    errString := string;
  else
    errString := "... "+ModelicaStrings_substring(string, index2-maxIndex, 
      lenString);
    index2 := maxIndex+5;
  end if;
  if (ModelicaStrings_length(errString) > maxLenString) then 
    errString := ModelicaStrings_substring(errString, 1, maxLenString)+" ...";
  end if;
  ModelicaError("Syntax error at character "+       String(index, true, 0)+
    " of\n"+errString+"\n"+Modelica.Utilities.Strings.repeat(index2-1, " ")+"*"+
    "\n"+message);
end Modelica.Utilities.Strings.syntaxError;
*/
DYMOLA_STATIC void Modelica_Utilities_Strings_syntaxError(const char*  string0_0,
   int  index0_0, const char*  message0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Strings.syntaxError")
  {
    /* Declare outputs and temporaries */
    int   maxIndex0_0;
    int   maxLenString0_0;
    int   lenString0_0;
    const char*   errString0_0;
    int   index20_0;
    maxIndex0_0 = 40;
    maxLenString0_0 = 60;
    lenString0_0 = ModelicaStrings_length(string0_0);
    errString0_0="";
    index20_0 = IF index0_0 < 1 THEN 1 ELSE IF index0_0 > lenString0_0 THEN 
      lenString0_0 ELSE index0_0;
    /* Start of real code */
      if (index20_0 <= maxIndex0_0) {
        errString0_0 = string0_0;
      }
      else{
        errString0_0 = StringAdd("... ",ModelicaStrings_substring(string0_0, 
          index20_0-maxIndex0_0, lenString0_0));
        index20_0 = maxIndex0_0+5;
      }
      if (ModelicaStrings_length(errString0_0) > maxLenString0_0) {
        errString0_0 = StringAdd(ModelicaStrings_substring(errString0_0, 1, 
          maxLenString0_0)," ...");
      }
      ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
        StringAdd(StringAdd("Syntax error at character ",Integer2String2(
        index0_0, true, 0))," of\n"),errString0_0),"\n"),Modelica_Utilities_Strings_repeat
        (index20_0-1, " ")),"*"),"\n"),message0_0));
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Examples.expression
  input String string "Expression that is evaluated";
  input Integer startIndex := 1 "Start scanning of expression at character startIndex";
  input String message := "" "Message used in error message if scan is not successful";
  output Real result "Value of expression";
  output Integer nextIndex "Index after the scanned expression";
protected 
  Real result2;
  String signOfNumber;
  Boolean scanning := true;
  String opString;
  public 
algorithm 
  (signOfNumber, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string,
     startIndex, {"+", "-", ""}, message);
  (result, nextIndex)  := Modelica.Utilities.Examples.expression.term(string, 
    nextIndex, message);
  if (signOfNumber == "-") then 
    result :=  -result;
  end if;
  while scanning loop
    (opString, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string, 
      nextIndex, {"+", "-", ""}, message);
    if (opString == "") then 
      scanning := false;
    else
      (result2, nextIndex)  := Modelica.Utilities.Examples.expression.term(
        string, nextIndex, message);
      result := (if opString == "+" then result+result2 else result-result2);
    end if;
  end while;
end Modelica.Utilities.Examples.expression;
*/
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_struct 
  Modelica_Utilities_Examples_expression(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Examples.expression")
  {
    /* Declare outputs and temporaries */
    double   result0_0;
    int   nextIndex0_0;
    double   result20_0;
    const char*   signOfNumber0_0;
    int   scanning0_0;
    const char*   opString0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nextIndex0_0=0;
    result20_0=0;
    signOfNumber0_0="";
    scanning0_0 = true;
    opString0_0="";
    /* Start of real code */
      {
        struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
          Modelica_Utilities_Strings_scanDelimiter(string0_0, startIndex0_0, 
          StringTemporaryDense( DymArrays2, 1, 3), message0_0);
        signOfNumber0_0 = dummy_mult_.delimiter0_0_0member;
        nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
      }
      Release();
      {
        struct Modelica_Utilities_Examples_expression_term_struct dummy_mult_=
          Modelica_Utilities_Examples_expression_term(string0_0, nextIndex0_0, 
          message0_0);
        result0_0 = dummy_mult_.result0_0_0member;
        nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
      }
      if ((strcmp(signOfNumber0_0, "-")==0)) {
        result0_0 =  -result0_0;
      }
      while (scanning0_0) {
        {
          struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
            Modelica_Utilities_Strings_scanDelimiter(string0_0, nextIndex0_0, 
            StringTemporaryDense( DymArrays2, 1, 3), message0_0);
          opString0_0 = dummy_mult_.delimiter0_0_0member;
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
        }
        Release();
        if ((strcmp(opString0_0, "")==0)) {
          scanning0_0 = false;
        }
        else{
          {
            struct Modelica_Utilities_Examples_expression_term_struct
               dummy_mult_=Modelica_Utilities_Examples_expression_term(string0_0,
               nextIndex0_0, message0_0);
            result20_0 = dummy_mult_.result0_0_0member;
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          }
          result0_0 = IF (strcmp(opString0_0, "+")==0) THEN result0_0+result20_0
             ELSE result0_0-result20_0;
        }
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    {
      struct Modelica_Utilities_Examples_expression_struct out_;
      out_.result0_0_0member = result0_0;
      out_.nextIndex0_0_0member = nextIndex0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Examples.expression.term
  input String string;
  input Integer startIndex;
  input String message := "";
  output Real result;
  output Integer nextIndex;
protected 
  Real result2;
  Boolean scanning := true;
  String opString;
  public 
algorithm 
  (result, nextIndex)  := Modelica.Utilities.Examples.expression.primary(string,
     startIndex, message);
  while scanning loop
    (opString, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string, 
      nextIndex, {"*", "/", ""}, message);
    if (opString == "") then 
      scanning := false;
    else
      (result2, nextIndex)  := Modelica.Utilities.Examples.expression.primary(
        string, nextIndex, message);
      result := (if opString == "*" then result*result2 else result/result2);
    end if;
  end while;
end Modelica.Utilities.Examples.expression.term;
*/
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_term_struct 
  Modelica_Utilities_Examples_expression_term(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Examples.expression.term")
  {
    /* Declare outputs and temporaries */
    double   result0_0;
    int   nextIndex0_0;
    double   result20_0;
    int   scanning0_0;
    const char*   opString0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nextIndex0_0=0;
    result20_0=0;
    scanning0_0 = true;
    opString0_0="";
    /* Start of real code */
      {
        struct Modelica_Utilities_Examples_expression_primary_struct
           dummy_mult_=Modelica_Utilities_Examples_expression_primary(string0_0,
           startIndex0_0, message0_0);
        result0_0 = dummy_mult_.result0_0_0member;
        nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
      }
      while (scanning0_0) {
        {
          struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
            Modelica_Utilities_Strings_scanDelimiter(string0_0, nextIndex0_0, 
            StringTemporaryDense( DymArrays3, 1, 3), message0_0);
          opString0_0 = dummy_mult_.delimiter0_0_0member;
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
        }
        Release();
        if ((strcmp(opString0_0, "")==0)) {
          scanning0_0 = false;
        }
        else{
          {
            struct Modelica_Utilities_Examples_expression_primary_struct
               dummy_mult_=Modelica_Utilities_Examples_expression_primary(
              string0_0, nextIndex0_0, message0_0);
            result20_0 = dummy_mult_.result0_0_0member;
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          }
          result0_0 = IF (strcmp(opString0_0, "*")==0) THEN result0_0*result20_0
             ELSE divmacro(result0_0,"result",result20_0,"result2");
        }
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    {
      struct Modelica_Utilities_Examples_expression_term_struct out_;
      out_.result0_0_0member = result0_0;
      out_.nextIndex0_0_0member = nextIndex0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.Advanced.skipLineComments
  input String string;
  input Integer startIndex := 1;
  output Integer nextIndex;
protected 
  Integer lenString := ModelicaStrings_length(string);
  Boolean scanning;
  Boolean lineComment;
  public 
algorithm 
  nextIndex := startIndex;
  scanning := true;
  while scanning loop
    nextIndex := ModelicaStrings_skipWhiteSpace(string, nextIndex);
    if (nextIndex+1 <= lenString) then 
      if (ModelicaStrings_substring(string, nextIndex, nextIndex+1) == "//")
         then 
        nextIndex := nextIndex+2;
        if (nextIndex <= lenString) then 
          lineComment := true;
          while lineComment loop
            if (ModelicaStrings_substring(string, nextIndex, nextIndex) == "\n")
               then 
              lineComment := false;
            end if;
            nextIndex := nextIndex+1;
            if (nextIndex > lenString) then 
              lineComment := false;
              scanning := false;
            end if;
          end while;
        else
          scanning := false;
        end if;
      else
        scanning := false;
      end if;
    else
      scanning := false;
    end if;
  end while;
end Modelica.Utilities.Strings.Advanced.skipLineComments;
*/
DYMOLA_STATIC int   Modelica_Utilities_Strings_Advanced_skipLineComments(
  const char*  string0_0, int  startIndex0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Strings.Advanced.skipLineComments")
  {
    /* Declare outputs and temporaries */
    int   nextIndex0_0;
    int   lenString0_0;
    int   scanning0_0;
    int   lineComment0_0;
    nextIndex0_0=0;
    lenString0_0 = ModelicaStrings_length(string0_0);
    scanning0_0=0;
    lineComment0_0=0;
    /* Start of real code */
      nextIndex0_0 = startIndex0_0;
      scanning0_0 = true;
      while (scanning0_0) {
        nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, nextIndex0_0);
        if (nextIndex0_0+1 <= lenString0_0) {
          if ((strcmp(ModelicaStrings_substring(string0_0, nextIndex0_0, 
            nextIndex0_0+1), "//")==0)) {
            nextIndex0_0 = nextIndex0_0+2;
            if (nextIndex0_0 <= lenString0_0) {
              lineComment0_0 = true;
              while (lineComment0_0) {
                if ((strcmp(ModelicaStrings_substring(string0_0, nextIndex0_0, 
                  nextIndex0_0), "\n")==0)) {
                  lineComment0_0 = false;
                }
                nextIndex0_0 = nextIndex0_0+1;
                if (nextIndex0_0 > lenString0_0) {
                  lineComment0_0 = false;
                  scanning0_0 = false;
                }
              }
            }
            else{
              scanning0_0 = false;
            }
          }
          else{
            scanning0_0 = false;
          }
        }
        else{
          scanning0_0 = false;
        }
      }
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    return nextIndex0_0;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.repeat
  input Integer n := 1 "Number of occurences";
  input String string := " " "String that is repeated";
  output String repeatedString "String containing n concatenated strings";

algorithm 
  repeatedString := "";
  for i in (1:n) loop
    repeatedString := repeatedString+string;
  end for;
end Modelica.Utilities.Strings.repeat;
*/
DYMOLA_STATIC const char*   Modelica_Utilities_Strings_repeat(int  n0_0, 
  const char*  string0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Strings.repeat")
  {
    /* Declare outputs and temporaries */
    const char*   repeatedString0_0;
    MarkObject retmark_ = PushMark();
    repeatedString0_0="";
    /* Start of real code */
      repeatedString0_0 = "";
      {
        int end_ = n0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          repeatedString0_0 = StringAdd(repeatedString0_0,string0_0);
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return SqueezeString(repeatedString0_0, retSMark_);
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Examples.expression.primary
  input String string;
  input Integer startIndex;
  input String message := "";
  output Real result;
  output Integer nextIndex;
protected 
  Modelica.Utilities.Types.TokenValue token;
  Real result2;
  String delimiter;
  String functionName;
  Real pi := 3.14159265358979;
  public 
algorithm 
  (token, nextIndex)  := Modelica.Utilities.Strings.scanToken(string, startIndex,
     true);
  if (token.tokenType == Modelica.Utilities.Types.TokenType.DelimiterToken and 
    token.string == "(") then 
    (result, nextIndex)  := Modelica.Utilities.Examples.expression(string, 
      nextIndex, message);
    (delimiter, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string, 
      nextIndex, {")"}, message);
  elseif (token.tokenType == Modelica.Utilities.Types.TokenType.RealToken) then 
    result := token.real;
  elseif (token.tokenType == Modelica.Utilities.Types.TokenType.IntegerToken)
     then 
    result := token.integer;
  elseif (token.tokenType == Modelica.Utilities.Types.TokenType.IdentifierToken)
     then 
    if (token.string == "pi") then 
      result := pi;
    else
      functionName := token.string;
      (delimiter, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string,
         nextIndex, {"("}, message);
      (result, nextIndex)  := Modelica.Utilities.Examples.expression(string, 
        nextIndex, message);
      (delimiter, nextIndex)  := Modelica.Utilities.Strings.scanDelimiter(string,
         nextIndex, {")"}, message);
      if (functionName == "sin") then 
        result := sin(result);
      elseif (functionName == "cos") then 
        result := cos(result);
      elseif (functionName == "tan") then 
        result := tan(result);
      elseif (functionName == "sqrt") then 
        if (result < 0.0) then 
          Modelica.Utilities.Strings.syntaxError(string, startIndex, 
            "Argument of call \"sqrt("+       String(result, true, 0)+
            ")\" is negative.\n"+"Imaginary numbers are not supported by the calculator.\n"
            +message);
        end if;
        result := sqrt(result);
      else
        Modelica.Utilities.Strings.syntaxError(string, startIndex, "Function \""
          +functionName+"\" is unknown (not supported)\n"+message);
      end if;
    end if;
  else
    Modelica.Utilities.Strings.syntaxError(string, startIndex, "Invalid primary of expression.\n"
      +message);
  end if;
end Modelica.Utilities.Examples.expression.primary;
*/
DYMOLA_STATIC struct Modelica_Utilities_Examples_expression_primary_struct 
  Modelica_Utilities_Examples_expression_primary(const char*  string0_0, int  
  startIndex0_0, const char*  message0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Utilities.Examples.expression.primary")
  {
    /* Declare outputs and temporaries */
    double   result0_0;
    int   nextIndex0_0;
    struct DymStruc0  token0_0;
    double   result20_0;
    const char*   delimiter0_0;
    const char*   functionName0_0;
    double   pi0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nextIndex0_0=0;
    token0_0.tokenType_0member=0;
    token0_0.real_0member=0;
    token0_0.integer_0member=0;
    token0_0.boolean_0member=0;
    token0_0.string_0member="";
    result20_0=0;
    delimiter0_0="";
    functionName0_0="";
    pi0_0 = 3.14159265358979;
    /* Start of real code */
      {
        struct Modelica_Utilities_Strings_scanToken_struct dummy_mult_=
          Modelica_Utilities_Strings_scanToken(string0_0, startIndex0_0, true);
        token0_0 = dummy_mult_.token0_0_0member;
        nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
      }
      if (token0_0.tokenType_0member == 6 AND (strcmp(token0_0.string_0member, 
        "(")==0)) {
        {
          struct Modelica_Utilities_Examples_expression_struct dummy_mult_=
            Modelica_Utilities_Examples_expression(string0_0, nextIndex0_0, 
            message0_0);
          result0_0 = dummy_mult_.result0_0_0member;
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
        }
        {
          struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
            Modelica_Utilities_Strings_scanDelimiter(string0_0, nextIndex0_0, 
            StringTemporaryDense( DymArrays4, 1, 1), message0_0);
          delimiter0_0 = dummy_mult_.delimiter0_0_0member;
          nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
        }
        Release();
      }
      else if (token0_0.tokenType_0member == 1) {
        result0_0 = token0_0.real_0member;
      }
      else if (token0_0.tokenType_0member == 2) {
        result0_0 = token0_0.integer_0member;
      }
      else if (token0_0.tokenType_0member == 5) {
        if ((strcmp(token0_0.string_0member, "pi")==0)) {
          result0_0 = pi0_0;
        }
        else{
          functionName0_0 = token0_0.string_0member;
          {
            struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
              Modelica_Utilities_Strings_scanDelimiter(string0_0, nextIndex0_0, 
              StringTemporaryDense( DymArrays5, 1, 1), message0_0);
            delimiter0_0 = dummy_mult_.delimiter0_0_0member;
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          }
          Release();
          {
            struct Modelica_Utilities_Examples_expression_struct dummy_mult_=
              Modelica_Utilities_Examples_expression(string0_0, nextIndex0_0, 
              message0_0);
            result0_0 = dummy_mult_.result0_0_0member;
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          }
          {
            struct Modelica_Utilities_Strings_scanDelimiter_struct dummy_mult_=
              Modelica_Utilities_Strings_scanDelimiter(string0_0, nextIndex0_0, 
              StringTemporaryDense( DymArrays4, 1, 1), message0_0);
            delimiter0_0 = dummy_mult_.delimiter0_0_0member;
            nextIndex0_0 = dummy_mult_.nextIndex0_0_0member;
          }
          Release();
          if ((strcmp(functionName0_0, "sin")==0)) {
            result0_0 = sin(result0_0);
          }
          else if ((strcmp(functionName0_0, "cos")==0)) {
            result0_0 = cos(result0_0);
          }
          else if ((strcmp(functionName0_0, "tan")==0)) {
            result0_0 = tan(result0_0);
          }
          else if ((strcmp(functionName0_0, "sqrt")==0)) {
            if (result0_0 < 0.0) {
              Modelica_Utilities_Strings_syntaxError(string0_0, startIndex0_0, 
                StringAdd(StringAdd(StringAdd(StringAdd("Argument of call \"sqrt(",
                Real2String2(result0_0, true, 0)),")\" is negative.\n"),
                "Imaginary numbers are not supported by the calculator.\n"),
                message0_0));
            }
            result0_0 = sqrtGuarded(result0_0,"result");
          }
          else{
            Modelica_Utilities_Strings_syntaxError(string0_0, startIndex0_0, 
              StringAdd(StringAdd(StringAdd("Function \"",functionName0_0),
              "\" is unknown (not supported)\n"),message0_0));
          }
        }
      }
      else{
        Modelica_Utilities_Strings_syntaxError(string0_0, startIndex0_0, 
          StringAdd("Invalid primary of expression.\n",message0_0));
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    {
      struct Modelica_Utilities_Examples_expression_primary_struct out_;
      out_.result0_0_0member = result0_0;
      out_.nextIndex0_0_0member = nextIndex0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#include <moutil.c>
DYMOLA_STATIC const char*modelName="TanklessWaterHeater.Examples.NonCondensingTanklessExample";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/peter grant/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[19]={6 , 3 , 1 , 4 , 7 , 3 , 2 , 5 , 8 , 3 , 3
   , 6 , 9 , 1 , 10 , 1 , 11 , 1 , 12};
DYMOLA_STATIC long QJacobianGC_[73]={
1 , 1 , 4 , 4 , 4 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 5 , 5 , 5 , 8 , 8 , 8
   , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 6 , 6 , 6 , 9 , 9 , 9 , 0 , 0 , 10 , 10 , 10 , 10
   , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11
   , 11 , 11 , 11 , 0 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12
   , 0};
DYMOLA_STATIC double QJacobianCD_[13]={0  , 44 , 50 , 54 , 77 , 80 , 81 , 110 , 110
   , 108 , 104 , 98 , 90};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[71] = 4;
W_[89] = true;
W_[90] = true;
W_[133] = 1;
W_[136] = 1;
W_[139] = 1;
W_[142] = 1;
W_[75] = 5;
W_[76] = true;
W_[88] = true;
W_[148] = 3;
W_[153] = 1;
W_[102] = 55555;
W_[126] = 10;
W_[132] = true;
W_[135] = true;
W_[138] = true;
W_[141] = true;
W_[109] = 1;
W_[112] = 0;
W_[111] = 0;
W_[107] = 1;
BoundParameterSection
AssertModelica(DP_[7] >= DP_[8],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.yMax >= nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[7], true, 0)),") < yMin (="),Real2String2(DP_[8], true, 0)),
  ")"));;
PopAllMarks();
W_[0] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Capacitance_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Capacitance_input"));
PopModelContext();
W_[1] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"SteadyStateEff_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "SteadyStateEff_input"));
PopModelContext();
W_[2] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"UA_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "UA_input"));
PopModelContext();
W_[3] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"T_Set_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "T_Set_input"));
PopModelContext();
W_[4] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"mdot_min_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "mdot_min_input"));
PopModelContext();
W_[5] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"SpecificHeat_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "SpecificHeat_input"));
PopModelContext();
W_[6] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_k_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_k_input"));
PopModelContext();
W_[7] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_I_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_I_input"));
PopModelContext();
W_[8] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_D_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_D_input"));
PopModelContext();
W_[9] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"EffPilot_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "EffPilot_input"));
PopModelContext();
W_[10] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_Pilot_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_Pilot_input"));
PopModelContext();
W_[11] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_Rated_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_Rated_input"));
PopModelContext();
W_[12] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_min_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_min_input"));
PopModelContext();
W_[117] = W_[0];
W_[13] = W_[117];
W_[118] = W_[1];
W_[14] = W_[118];
W_[119] = W_[2];
W_[15] = W_[119];
W_[16] = W_[126];
W_[127] = W_[9];
W_[17] = W_[127];
W_[128] = W_[10];
W_[18] = W_[128];
W_[129] = W_[11];
W_[19] = W_[129];
W_[122] = W_[5];
W_[20] = W_[122];
W_[120] = W_[3];
W_[21] = W_[120];
W_[22] = DP_[22];
W_[123] = W_[6];
W_[104] = W_[123];
W_[72] = W_[104];
W_[124] = W_[7];
W_[105] = W_[124];
W_[73] = W_[105];
W_[125] = W_[8];
W_[106] = W_[125];
W_[74] = W_[106];
W_[77] = DP_[20];
W_[91] = IF DP_[19] THEN -1 ELSE 1;
W_[79] = W_[91]*DP_[9];
W_[80] =  -W_[91];
W_[82] = W_[72];
W_[86] = DP_[7];
W_[87] = DP_[8];
W_[103] = W_[118];
W_[94] = W_[103];
W_[95] = W_[102];
W_[101] = W_[122];
W_[96] = W_[101];
W_[100] = W_[120];
W_[97] = W_[100];
W_[121] = W_[4];
W_[98] = W_[121];
W_[130] = W_[12];
W_[99] = W_[130];
W_[145] = W_[91]*DP_[10];
W_[146] =  -W_[91];
W_[147] = divmacro(1,"1",W_[73],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ti");
W_[149] = DP_[13];
W_[151] = W_[74];
helpvar[0] = divmacro(1.0,"1.0",DP_[12],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Nd");
W_[152] = RealBmax(helpvar[0]*W_[74], 1E-014);
W_[154] = DP_[14];
if (NewParameters) {
helpvar[1] = fabs(W_[151]);
}
W_[155] = fabs(W_[151]) < 1E-015;
W_[156] = W_[91];
W_[157] =  -W_[91];
W_[160] = divmacro(1,"1",W_[72]*DP_[11],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.k*nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ni");
InitialSection
InitialSection2
X_[10] = W_[149];
X_[11] = W_[154];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
W_[0] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Capacitance_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Capacitance_input"));
PopModelContext();
W_[1] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"SteadyStateEff_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "SteadyStateEff_input"));
PopModelContext();
W_[2] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"UA_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "UA_input"));
PopModelContext();
W_[3] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"T_Set_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "T_Set_input"));
PopModelContext();
W_[4] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"mdot_min_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "mdot_min_input"));
PopModelContext();
W_[5] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"SpecificHeat_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "SpecificHeat_input"));
PopModelContext();
W_[6] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_k_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_k_input"));
PopModelContext();
W_[7] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_I_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_I_input"));
PopModelContext();
W_[8] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"PID_D_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "PID_D_input"));
PopModelContext();
W_[9] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"EffPilot_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "EffPilot_input"));
PopModelContext();
W_[10] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_Pilot_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_Pilot_input"));
PopModelContext();
W_[11] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_Rated_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_Rated_input"));
PopModelContext();
W_[12] = (PushModelContext(1,"Modelica.Utilities.Examples.readRealParameter(\"TanklessExampleParameters.txt\", \"Qdot_min_input\")")
  Modelica_Utilities_Examples_readRealParameter("TanklessExampleParameters.txt",
   "Qdot_min_input"));
PopModelContext();
W_[117] = W_[0];
W_[13] = W_[117];
W_[118] = W_[1];
W_[14] = W_[118];
W_[119] = W_[2];
W_[15] = W_[119];
W_[127] = W_[9];
W_[17] = W_[127];
W_[128] = W_[10];
W_[18] = W_[128];
W_[129] = W_[11];
W_[19] = W_[129];
W_[122] = W_[5];
W_[20] = W_[122];
W_[120] = W_[3];
W_[21] = W_[120];
W_[22] = DP_[22];
W_[123] = W_[6];
W_[104] = W_[123];
W_[72] = W_[104];
W_[124] = W_[7];
W_[105] = W_[124];
W_[73] = W_[105];
W_[125] = W_[8];
W_[106] = W_[125];
W_[74] = W_[106];
W_[77] = DP_[20];
W_[91] = IF DP_[19] THEN -1 ELSE 1;
W_[79] = W_[91]*DP_[9];
W_[80] =  -W_[91];
W_[82] = W_[72];
W_[86] = DP_[7];
W_[87] = DP_[8];
AssertModelica(W_[86] >= W_[87],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMax >= nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[86], true, 0)),") < uMin (="),Real2String2(W_[87], true, 0)),
  ")"));;
PopAllMarks();
W_[103] = W_[118];
W_[94] = W_[103];
W_[95] = W_[102];
W_[101] = W_[122];
W_[96] = W_[101];
W_[100] = W_[120];
W_[97] = W_[100];
W_[121] = W_[4];
W_[98] = W_[121];
W_[130] = W_[12];
W_[99] = W_[130];
W_[145] = W_[91]*DP_[10];
W_[146] =  -W_[91];
W_[147] = divmacro(1,"1",W_[73],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ti");
W_[149] = DP_[13];
W_[151] = W_[74];
W_[152] = RealBmax(divmacro(W_[74],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Td",
  DP_[12],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Nd"),
   1E-014);
W_[154] = DP_[14];
W_[156] = W_[91];
W_[157] =  -W_[91];
W_[160] = divmacro(1,"1",W_[72]*DP_[11],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.k*nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ni");
W_[16] = W_[126];
W_[155] = fabs(W_[151]) < 1E-015;
X_[11] = W_[154];
X_[10] = W_[149];
InitialSection
W_[134] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableInit(\"Ambient\", \"C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleAmbientTemperature.txt\", TAmb.table, TAmb.smoothness)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M("Ambient", "C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleAmbientTemperature.txt",
   RealTemporaryDense( (Real*)(0), 2, 0, 2), DP_[24]));
PopAllMarks();
W_[137] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableInit(\"Inlet\", \"C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleInletTemperature.txt\", TIn.table, TIn.smoothness)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M("Inlet", "C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleInletTemperature.txt",
   RealTemporaryDense( (Real*)(0), 2, 0, 2), DP_[26]));
PopAllMarks();
W_[140] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableInit(\"Flow\", \"C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleDemandFlowPattern.txt\", drawPat.table, drawPat.smoothness)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M("Flow", "C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExampleDemandFlowPattern.txt",
   RealTemporaryDense( (Real*)(0), 2, 0, 2), DP_[28]));
PopAllMarks();
W_[143] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableInit(\"Power\", \"C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExamplePowerSignal.txt\", pwrSig.table, pwrSig.smoothness)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableInit_M("Power", "C:/Program Files (x86)/Dymola 2012 FD01/Models/models/modelica/WaterHeater/current/modeling/branches/pgrant/TanklessWaterHeater/TanklessExamplePowerSignal.txt",
   RealTemporaryDense( (Real*)(0), 2, 0, 2), DP_[30]));
PopAllMarks();
InitialSection
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection

DynamicsSection
W_[131] = Time;
W_[113] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(drawPat.tableID, drawPat.columns[1], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[140], DP_[27], W_[131]));
PopModelContext();
W_[62] = W_[113]*W_[101];
W_[115] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(TIn.tableID, TIn.columns[1], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[137], DP_[25], W_[131]));
PopModelContext();
W_[61] = DP_[1]*W_[115]+DP_[2]*W_[100];
W_[63] = W_[62]*W_[61];
W_[116] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(pwrSig.tableID, pwrSig.columns[1], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[143], DP_[29], W_[131]));
PopModelContext();
W_[59] = IF Greater(W_[63],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.y",
   55555*W_[94],"55555*nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.SteadyStateEff",
   0) AND Greater(W_[116],"nonCondensingTanklessHeater.pwrSig", 0,"0", 1) THEN 
  divmacro(55555*W_[94],"55555*nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.SteadyStateEff",
  W_[96]*(W_[97]-W_[115]),"nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.SpecificHeat*(nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.T_Set-nonCondensingTanklessHeater.InletTemperature)")
   ELSE W_[113];
W_[23] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[67] = GreaterEqual(W_[113],"nonCondensingTanklessHeater.DemandFlowRate", 
  W_[98],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_min_cons",
   2);
W_[64] = IF W_[67] THEN DP_[3] ELSE DP_[4];
W_[68] = GreaterEqual(W_[63],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.y",
   W_[99],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_min_cons",
   3);
W_[65] = IF W_[68] THEN DP_[5] ELSE DP_[6];
W_[66] = W_[64]*W_[65];
W_[78] = W_[79]*W_[100]+W_[80]*X_[9];
W_[81] = DP_[15]*W_[78];
W_[144] = W_[145]*W_[100]+W_[146]*X_[9];
W_[85] = IF W_[155] THEN 0 ELSE divmacro(W_[151]*(W_[144]-X_[11]),
  "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.k*(nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.y-nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.x)",
  W_[152],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.T");
W_[83] = DP_[16]*W_[81]+DP_[17]*W_[85]+DP_[18]*X_[10];
W_[84] = W_[82]*W_[83];
W_[69] = IF GreaterS(W_[84],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.y",
   W_[86],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMax",
   4) THEN W_[86] ELSE IF LessS(W_[84],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.y",
   W_[87],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMin",
   5) THEN W_[87] ELSE W_[84];
W_[108] = RealBmin(W_[69], 1);
W_[92] = RealBmax(W_[108], 0);
W_[93] = W_[66]*W_[92];
W_[110] = W_[93]*W_[116];
W_[60] = delay(W_[110], DP_[21], 0);
W_[114] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.tableIpo(TAmb.tableID, TAmb.columns[1], Time.y)")
  Modelica_Blocks_Tables_CombiTable1Ds_tableIpo_M(W_[134], DP_[23], W_[131]));
PopModelContext();
W_[33] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*W_[115]+10
  *DP_[0]*(X_[1]+W_[115])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[0] = W_[23]*X_[0]+W_[33];
W_[24] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[34] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[0]+10*
  DP_[0]*(X_[2]+X_[0])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[1] = W_[24]*X_[1]+W_[34];
W_[25] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[35] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[1]+10*
  DP_[0]*(X_[3]+X_[1])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[2] = W_[25]*X_[2]+W_[35];
W_[26] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[36] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[2]+10*
  DP_[0]*(X_[4]+X_[2])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[3] = W_[26]*X_[3]+W_[36];
W_[27] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[37] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[3]+10*
  DP_[0]*(X_[5]+X_[3])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[4] = W_[27]*X_[4]+W_[37];
W_[28] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[38] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[4]+10*
  DP_[0]*(X_[6]+X_[4])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[5] = W_[28]*X_[5]+W_[38];
W_[29] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[39] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[5]+10*
  DP_[0]*(X_[7]+X_[5])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[6] = W_[29]*X_[6]+W_[39];
W_[30] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[40] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[6]+10*
  DP_[0]*(X_[8]+X_[6])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[7] = W_[30]*X_[7]+W_[40];
W_[31] =  -divmacro(10*W_[59]*W_[20]+20*DP_[0]+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat)+20*nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[41] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[7]+10*
  DP_[0]*(X_[9]+X_[7])+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[8] = W_[31]*X_[8]+W_[41];
F_[11] = IF W_[155] THEN 0 ELSE divmacro(W_[144]-X_[11],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.y-nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.x",
  W_[152],"nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.T");
W_[32] =  -divmacro(10*(W_[59]*W_[20]+DP_[0])+W_[15],"10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat+nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient)+nonCondensingTanklessHeater.HeatExchanger.UA",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
W_[42] = divmacro(W_[14]*W_[60]*W_[19]+W_[17]*W_[18]+10*W_[59]*W_[20]*X_[8]+10*
  DP_[0]*X_[8]+W_[15]*W_[114],"nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff*nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated+nonCondensingTanklessHeater.HeatExchanger.EffPilot*nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot+10*(nonCondensingTanklessHeater.HeatExchanger.mdot_water*nonCondensingTanklessHeater.HeatExchanger.SpecificHeat*nonCondensing...",
  W_[13],"nonCondensingTanklessHeater.HeatExchanger.Capacitance");
F_[9] = W_[32]*X_[9]+W_[42];
W_[159] = DP_[33]*W_[69]+DP_[34]*W_[84];
W_[158] = W_[160]*W_[159];
W_[150] = W_[156]*W_[100]+W_[157]*X_[9]+DP_[32]*W_[158];
F_[10] = W_[147]*W_[150];

AcceptedSection1

AcceptedSection2
W_[43] = W_[59]*W_[20]*(X_[9]-W_[115]);
W_[44] = 0.1*W_[15]*(X_[0]-W_[114]);
W_[45] = 0.1*W_[15]*(X_[1]-W_[114]);
W_[46] = 0.1*W_[15]*(X_[2]-W_[114]);
W_[47] = 0.1*W_[15]*(X_[3]-W_[114]);
W_[48] = 0.1*W_[15]*(X_[4]-W_[114]);
W_[49] = 0.1*W_[15]*(X_[5]-W_[114]);
W_[50] = 0.1*W_[15]*(X_[6]-W_[114]);
W_[51] = 0.1*W_[15]*(X_[7]-W_[114]);
W_[52] = 0.1*W_[15]*(X_[8]-W_[114]);
W_[53] = 0.1*W_[15]*(X_[9]-W_[114]);
W_[54] = W_[44]+W_[45]+W_[46]+W_[47]+W_[48]+W_[49]+W_[50]+W_[51]+W_[52]+W_[53];
W_[55] = 0.1*W_[13]*(X_[0]+X_[1]+X_[2]+X_[3]+X_[4]+X_[5]+X_[6]+X_[7]+X_[8]+X_[9]);
W_[56] = 0.1*(X_[0]+X_[1]+X_[2]+X_[3]+X_[4]+X_[5]+X_[6]+X_[7]+X_[8]+X_[9]);
W_[57] = W_[18]+W_[19]*W_[60];
W_[58] = IF Greater(W_[60],"nonCondensingTanklessHeater.HeatExchanger.ControlConstant",
   0,"0", 6) THEN divmacro(W_[60]*W_[19],"nonCondensingTanklessHeater.HeatExchanger.ControlConstant*nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated",
  W_[22],"nonCondensingTanklessHeater.HeatExchanger.EnergyDensityGas") ELSE 
  0.001;
W_[70] = W_[100]-X_[9];

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAlias(0)
StartNonAlias(0)
DeclareVariable("Cap_input", "[J/C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("SteadyStateEff_input", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("UA_input", "[W/C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("T_Set_input", "[C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("mdot_min_input", "[kg/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("SpecificHeat_input", "[J/(kg.C)]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID_k_input", "[1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID_I_input", "[s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID_D_input", "[s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("EffPilot_input", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Qdot_Pilot_input", "[W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Qdot_Rated_input", "[W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Qdot_min_input", "[W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Capacitance", \
"Thermal capacitance of the heat exchanger [J/C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.SteadyStateEff", \
"Heater efficiency at steady state", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.UA", "Coefficient describing heat loss to ambient conditions [W/C]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.HeatExchanger.ConductionCoefficient",\
 "Coefficient characterizing the conduction of heat in the heat exchanger [W/C]",\
 0, 1E-006, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.nNode", \
"Number of nodes the heat exchanger is broken into", 10, 0.0,0.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.EffPilot", \
"Efficiency of the pilot light", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Pilot", \
"Input heat rate of the pilot light [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Rated", \
"Rated capacity of the main burner [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.SpecificHeat", \
"Specific heat of the fluid being heated [J/(kg.C)]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.T_Set", \
"Set temperature of the tankless heater [C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.EnergyDensityGas", \
"[W/kg]", 0.0, 0.0,0.0,0.0,0,513)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[1]", "[C]", 0, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[1])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[2]", "[C]", 1, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[2])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[3]", "[C]", 2, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[3])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[4]", "[C]", 3, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[4])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[5]", "[C]", 4, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[5])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[6]", "[C]", 5, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[6])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[7]", "[C]", 6, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[7])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[8]", "[C]", 7, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[8])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[9]", "[C]", 8, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[9])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", "[C]", 9, 20,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("nonCondensingTanklessHeater.HeatExchanger.der(T_Node[10])", \
"[A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[1]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[2]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[3]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[4]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[5]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[6]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[7]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[8]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[9]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.a[10]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[1]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[2]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[3]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[4]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[5]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[6]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[7]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[8]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[9]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.b[10]", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Delivered", \
"[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[1]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[2]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[3]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[4]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[5]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[6]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[7]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[8]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[9]", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Env[10]", "[W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_Environment", \
"[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Q_Stored", "[J]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.AvgTemp", "[C]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.Qdot_in", "[W]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.mdot_g", "[kg/hr]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.mdot_water", "[kg/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.HeatExchanger.ControlConstant", "",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.HeatExchanger.T_Out", "[C]", \
"nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1, 1, 9, 0)
DeclareAlias2("nonCondensingTanklessHeater.HeatExchanger.T_amb", "", \
"nonCondensingTanklessHeater.AmbientTemperature", 1, 5, 114, 0)
DeclareAlias2("nonCondensingTanklessHeater.HeatExchanger.T_Inlet", "[C]", \
"nonCondensingTanklessHeater.InletTemperature", 1, 5, 115, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_out",\
 "[C]", "nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1, 1, 9, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.u1",\
 "Connector of Real input signal 1 [C]", "nonCondensingTanklessHeater.InletTemperature", 1,\
 5, 115, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.u2",\
 "Connector of Real input signal 2 [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.k1",\
 "Gain of upper input", 1, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.k2",\
 "Gain of lower input", 2, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product.u1",\
 "Connector of Real input signal 1 [kg/s]", "nonCondensingTanklessHeater.DemandFlowRate", 1,\
 5, 113, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product.u2",\
 "Connector of Real input signal 2 [J/(kg.C)]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.SpecificHeat_cons", 1,\
 5, 101, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product.y",\
 "Connector of Real output signal [V/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.u1",\
 "Connector of Real input signal 1 [V/s]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product.y", 1,\
 5, 62, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.u2",\
 "Connector of Real input signal 2", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.add.y", 1,\
 5, 61, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_water_controlled",\
 "[kg/s]", "nonCondensingTanklessHeater.HeatExchanger.mdot_water", 1, 5, 59, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.ControlConstant",\
 "", "nonCondensingTanklessHeater.HeatExchanger.ControlConstant", 1, 5, 60, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.u1",\
 "Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.u2",\
 "Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal.u",\
 "Connector of Boolean input signal", false, 0.0,0.0,0.0,0,642)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal.realTrue",\
 "Output signal for true Boolean input", 3, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal.realFalse",\
 "Output signal for false Boolean input", 4, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.u1", 1,\
 5, 64, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal1.u",\
 "Connector of Boolean input signal", false, 0.0,0.0,0.0,0,642)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal1.realTrue",\
 "Output signal for true Boolean input", 5, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal1.realFalse",\
 "Output signal for false Boolean input", 6, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal1.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.u2", 1,\
 5, 65, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.u_s",\
 "Connector of setpoint input signal [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.u_m",\
 "Connector of measurement input signal [C]", "nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1,\
 1, 9, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.y",\
 "Connector of actuator output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.controlError",\
 "Control error (set point - measurement) [C]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.controllerType",\
 "Type of controller", 4, 1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.k",\
 "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ti",\
 "Time constant of Integrator block [s]", 0.5, 1E-060,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Td",\
 "Time constant of Derivative block [s]", 0.1, 0.0,1E+100,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.yMax",\
 "Upper limit of output", 7, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.yMin",\
 "Lower limit of output", 8, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.wp",\
 "Set-point weight for Proportional block (0..1)", 9, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.wd",\
 "Set-point weight for Derivative block (0..1)", 10, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Ni",\
 "Ni*Ti is time constant of anti-windup compensation", 11, 0.9, 1E-013,1E+100,\
0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.Nd",\
 "The higher Nd, the more ideal the derivative block", 12, 10, 1E-013,1E+100,0.0,\
0,560)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.initType",\
 "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limitsAtInit",\
 "= false, if limits are ignored during initializiation", true, 0.0,0.0,0.0,0,515)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.xi_start",\
 "Initial or guess value value for integrator output (= integrator state)", 13, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.xd_start",\
 "Initial or guess value for state of derivative block", 14, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.y_start",\
 "Initial value of output", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.u1",\
 "Connector of Real input signal 1 [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.u2",\
 "Connector of Real input signal 2 [C]", "nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1,\
 1, 9, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.k1",\
 "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.k2",\
 "Gain of lower input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.P.k",\
 "Gain value multiplied with input signal [1]", 15, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.P.u",\
 "Input signal connector", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addP.y", 1,\
 5, 78, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.P.y",\
 "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.u",\
 "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.y",\
 "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.k1",\
 "Gain of upper input", 16, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.k2",\
 "Gain of middle input", 17, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.k3",\
 "Gain of lower input", 18, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.u1",\
 "Connector 1 of Real input signals", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.P.y", 1,\
 5, 81, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.u2",\
 "Connector 2 of Real input signals", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.u3",\
 "Connector 3 of Real input signals", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.y", 1,\
 1, 10, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.y",\
 "Connector of Real output signals", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.u", 1,\
 5, 83, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMax",\
 "Upper limits of input signals", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.uMin",\
 "Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.limitsAtInit",\
 "= false, if limits are ignored during initializiation (i.e., y=u)", true, \
0.0,0.0,0.0,0,515)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.u",\
 "Connector of Real input signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.y", 1,\
 5, 84, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.limiter.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.y", 1,\
 5, 69, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.with_I",\
 "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.with_D",\
 "", true, 0.0,0.0,0.0,0,1539)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.reverseAction",\
 "Set to true for throttling the water flow rate through a cooling coil controller",\
 19, false, 0.0,0.0,0.0,0,562)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.revAct",\
 "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product3.u1",\
 "Connector of Real input signal 1", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product2.y", 1,\
 5, 66, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product3.u2",\
 "Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product3.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.SteadyStateEff",\
 "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.Qdot_Rated",\
 "[W]", 55555, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.SpecificHeat",\
 "[J/(kg.C)]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.T_Set",\
 "[C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.Qdot_Required",\
 "", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.y", 1,\
 5, 63, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.mdot_water_controlled",\
 "[kg/s]", "nonCondensingTanklessHeater.HeatExchanger.mdot_water", 1, 5, 59, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.mdot_water",\
 "[kg/s]", "nonCondensingTanklessHeater.DemandFlowRate", 1, 5, 113, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.T_Inlet",\
 "[C]", "nonCondensingTanklessHeater.InletTemperature", 1, 5, 115, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.FlowRateControl.PowerSignal",\
 "", "nonCondensingTanklessHeater.pwrSig", 1, 5, 116, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual.u1",\
 "Connector of first Boolean input signal [kg/s]", "nonCondensingTanklessHeater.DemandFlowRate", 1,\
 5, 113, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual.u2",\
 "Connector of second Boolean input signal [kg/s]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_min_cons", 1,\
 5, 98, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual.y",\
 "Connector of Boolean output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal.u", 1,\
 5, 67, 65)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual1.u1",\
 "Connector of first Boolean input signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product1.y", 1,\
 5, 63, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual1.u2",\
 "Connector of second Boolean input signal [W]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_min_cons", 1,\
 5, 99, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.greaterEqual1.y",\
 "Connector of Boolean output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.booleanToReal1.u", 1,\
 5, 68, 65)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_water",\
 "[kg/s]", "nonCondensingTanklessHeater.DemandFlowRate", 1, 5, 113, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_min.y",\
 "Value of Real output [kg/s]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_min_cons", 1,\
 5, 98, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.mdot_min_cons",\
 "Minimum flow rate of the tankless heater [kg/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_min_cons",\
 "Minimum heat rate of the tankless heater [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons",\
 "Set Temperature [C]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.SpecificHeat_cons",\
 "Specific heat of the fluid being heated [J/(kg.C)]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_Rated_cons",\
 "Raed heat input rate of the tankless heater [W]", 55555, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.SteadyStateEff_cons",\
 "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID_k",\
 "[1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID_I",\
 "[s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID_D",\
 "[s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID_y_start",\
 "", 20, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.SpecificHeat.y",\
 "Value of Real output [J/(kg.C)]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.SpecificHeat_cons", 1,\
 5, 101, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set.y",\
 "Value of Real output [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_min.y",\
 "Value of Real output [W]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.Qdot_min_cons", 1,\
 5, 99, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.min.u1",\
 "Connector of Real input signal 1", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.y", 1,\
 5, 69, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.min.u2",\
 "Connector of Real input signal 2", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.min.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.ControlConstantMaximum.y",\
 "Value of Real output", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.fixedDelay.u",\
 "Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.fixedDelay.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.HeatExchanger.ControlConstant", 1,\
 5, 60, 0)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.fixedDelay.delayTime",\
 "Delay time of output with respect to input signal [s]", 21, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.max.u1",\
 "Connector of Real input signal 1", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.min.y", 1,\
 5, 108, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.max.u2",\
 "Connector of Real input signal 2", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.max.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product3.u2", 1,\
 5, 92, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.ControlConstantMinimum.y",\
 "Value of Real output", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Inlet",\
 "[C]", "nonCondensingTanklessHeater.InletTemperature", 1, 5, 115, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PowerSignal",\
 "", "nonCondensingTanklessHeater.pwrSig", 1, 5, 116, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product4.u1",\
 "Connector of Real input signal 1", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.product3.y", 1,\
 5, 93, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product4.u2",\
 "Connector of Real input signal 2", "nonCondensingTanklessHeater.pwrSig", 1, 5,\
 116, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.product4.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.fixedDelay.u", 1,\
 5, 110, 0)
DeclareVariable("nonCondensingTanklessHeater.DemandFlowRate", "[kg/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.AmbientTemperature", "", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.InletTemperature", "[C]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.pwrSig", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.Capacitance_input", "[J/C]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.SteadyStateEff_input", "", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.UA_input", "[W/C]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.T_Set_input", "[C]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.mdot_min_input", "[kg/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.SpecificHeat_input", "[J/(kg.C)]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.PID_k_input", "[1]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.PID_I_input", "[s]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.PID_D_input", "[s]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nNode_input", "", 10, 0.0,0.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.EffPilot_input", "", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.Qdot_Pilot_input", "[W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.Qdot_Rated_input", "[W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.EnergyDensityGas_input", "[W/kg]",\
 22, 13500, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHeater.Qdot_min_input", "[W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("Time.y", "Value of Real output [s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("TAmb.tableOnFile", "true, if table is defined on file or in function usertab",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("TAmb.columns[1]", "columns of table to be interpolated", 23, 2,\
 0.0,0.0,0.0,0,564)
DeclareParameter("TAmb.smoothness", "smoothness of table interpolation", 24, 1, \
1.0,2.0,0.0,0,564)
DeclareVariable("TAmb.nout", "Number of outputs", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("TAmb.u", "Connector of Real input signal [s]", "Time.y", 1, 5, 131,\
 0)
DeclareAlias2("TAmb.y[1]", "Connector of Real output signals", "nonCondensingTanklessHeater.AmbientTemperature", 1,\
 5, 114, 0)
DeclareVariable("TAmb.tableID", "", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("TIn.tableOnFile", "true, if table is defined on file or in function usertab",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("TIn.columns[1]", "columns of table to be interpolated", 25, 2,\
 0.0,0.0,0.0,0,564)
DeclareParameter("TIn.smoothness", "smoothness of table interpolation", 26, 1, \
1.0,2.0,0.0,0,564)
DeclareVariable("TIn.nout", "Number of outputs", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("TIn.u", "Connector of Real input signal [s]", "Time.y", 1, 5, 131,\
 0)
DeclareAlias2("TIn.y[1]", "Connector of Real output signals [C]", \
"nonCondensingTanklessHeater.InletTemperature", 1, 5, 115, 0)
DeclareVariable("TIn.tableID", "", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("drawPat.tableOnFile", "true, if table is defined on file or in function usertab",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("drawPat.columns[1]", "columns of table to be interpolated", 27,\
 2, 0.0,0.0,0.0,0,564)
DeclareParameter("drawPat.smoothness", "smoothness of table interpolation", 28, 1,\
 1.0,2.0,0.0,0,564)
DeclareVariable("drawPat.nout", "Number of outputs", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("drawPat.u", "Connector of Real input signal [s]", "Time.y", 1, 5,\
 131, 0)
DeclareAlias2("drawPat.y[1]", "Connector of Real output signals [kg/s]", \
"nonCondensingTanklessHeater.DemandFlowRate", 1, 5, 113, 0)
DeclareVariable("drawPat.tableID", "", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pwrSig.tableOnFile", "true, if table is defined on file or in function usertab",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pwrSig.columns[1]", "columns of table to be interpolated", 29,\
 2, 0.0,0.0,0.0,0,564)
DeclareParameter("pwrSig.smoothness", "smoothness of table interpolation", 30, 1,\
 1.0,2.0,0.0,0,564)
DeclareVariable("pwrSig.nout", "Number of outputs", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pwrSig.u", "Connector of Real input signal [s]", "Time.y", 1, 5, 131,\
 0)
DeclareAlias2("pwrSig.y[1]", "Connector of Real output signals", \
"nonCondensingTanklessHeater.pwrSig", 1, 5, 116, 0)
DeclareVariable("pwrSig.tableID", "", 0, 0.0,0.0,0.0,0,2565)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.u1",\
 "Connector of Real input signal 1 [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.u2",\
 "Connector of Real input signal 2 [C]", "nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1,\
 1, 9, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.k1",\
 "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.k2",\
 "Gain of lower input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.k",\
 "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.initType",\
 "Type of initialization (1: no init, 2: steady state, 3,4: initial output)", 3,\
 1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.y_start",\
 "Initial or guess value of output (= state)", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.u",\
 "Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.y",\
 "Connector of Real output signal", 10, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.der(y)",\
 "der(Connector of Real output signal)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.k",\
 "Gains [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.T",\
 "Time constants (T>0 required; T=0 is ideal derivative block) [s]", 1E-060, \
1E-060,1E+100,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.initType",\
 "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.x_start",\
 "Initial or guess value of state", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.y_start",\
 "Initial value of output (= state)", 31, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.u",\
 "Connector of Real input signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addD.y", 1,\
 5, 144, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.y",\
 "Connector of Real output signal", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addPID.u2", 1,\
 5, 85, 0)
DeclareState("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.x",\
 "State of block", 11, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.der(x)",\
 "der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.D.zeroGain",\
 "", false, 0.0,0.0,0.0,0,2563)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.k1",\
 "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.k2",\
 "Gain of middle input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.k3",\
 "Gain of lower input", 32, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.u1",\
 "Connector 1 of Real input signals [C]", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.T_Set_cons", 1,\
 5, 100, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.u2",\
 "Connector 2 of Real input signals [C]", "nonCondensingTanklessHeater.HeatExchanger.T_Node[10]", 1,\
 1, 9, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.u3",\
 "Connector 3 of Real input signals", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.y",\
 "Connector of Real output signals", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.I.u", 1,\
 5, 150, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.u1",\
 "Connector of Real input signal 1", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.y", 1,\
 5, 69, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.u2",\
 "Connector of Real input signal 2", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainPID.y", 1,\
 5, 84, 0)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.k1",\
 "Gain of upper input", 33, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.k2",\
 "Gain of lower input", 34, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainTrack.k",\
 "Gain value multiplied with input signal [1]", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainTrack.u",\
 "Input signal connector", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addSat.y", 1,\
 5, 159, 0)
DeclareAlias2("nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.gainTrack.y",\
 "Output signal connector", "nonCondensingTanklessHeater.nonCondensingTanklessHXController.PID.addI.u3", 1,\
 5, 158, 0)
EndNonAlias(0)
#define NX_    12
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    161
#define NP_    35
#define NPS_   0
#define NHash1_ 2127349758
#define NHash2_ 1933560040
#define NHash3_ -2028260331
#define NI_    0
#define NRelF_ 6
#define NRel_  7
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    69
#define SizePre_ 0
#define SizeEq_ 0
#define SizeDelay_ 1
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 2
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
EndDataBlock
